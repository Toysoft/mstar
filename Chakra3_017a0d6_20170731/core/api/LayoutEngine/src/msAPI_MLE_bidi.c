//<MStar Software>
//******************************************************************************
// MStar Software
// Copyright (c) 2010 - 2012 MStar Semiconductor, Inc. All rights reserved.
// All software, firmware and related documentation herein ("MStar Software") are
// intellectual property of MStar Semiconductor, Inc. ("MStar") and protected by
// law, including, but not limited to, copyright law and international treaties.
// Any use, modification, reproduction, retransmission, or republication of all
// or part of MStar Software is expressly prohibited, unless prior written
// permission has been granted by MStar.
//
// By accessing, browsing and/or using MStar Software, you acknowledge that you
// have read, understood, and agree, to be bound by below terms ("Terms") and to
// comply with all applicable laws and regulations:
//
// 1. MStar shall retain any and all right, ownership and interest to MStar
//    Software and any modification/derivatives thereof.
//    No right, ownership, or interest to MStar Software and any
//    modification/derivatives thereof is transferred to you under Terms.
//
// 2. You understand that MStar Software might include, incorporate or be
//    supplied together with third party`s software and the use of MStar
//    Software may require additional licenses from third parties.
//    Therefore, you hereby agree it is your sole responsibility to separately
//    obtain any and all third party right and license necessary for your use of
//    such third party`s software.
//
// 3. MStar Software and any modification/derivatives thereof shall be deemed as
//    MStar`s confidential information and you agree to keep MStar`s
//    confidential information in strictest confidence and not disclose to any
//    third party.
//
// 4. MStar Software is provided on an "AS IS" basis without warranties of any
//    kind. Any warranties are hereby expressly disclaimed by MStar, including
//    without limitation, any warranties of merchantability, non-infringement of
//    intellectual property rights, fitness for a particular purpose, error free
//    and in conformity with any international standard.  You agree to waive any
//    claim against MStar for any loss, damage, cost or expense that you may
//    incur related to your use of MStar Software.
//    In no event shall MStar be liable for any direct, indirect, incidental or
//    consequential damages, including without limitation, lost of profit or
//    revenues, lost or damage of data, and unauthorized system use.
//    You agree that this Section 4 shall still apply without being affected
//    even if MStar Software has been modified by MStar in accordance with your
//    request or instruction for your use, except otherwise agreed by both
//    parties in writing.
//
// 5. If requested, MStar may from time to time provide technical supports or
//    services in relation with MStar Software to you for your use of
//    MStar Software in conjunction with your or your customer`s product
//    ("Services").
//    You understand and agree that, except otherwise agreed by both parties in
//    writing, Services are provided on an "AS IS" basis and the warranty
//    disclaimer set forth in Section 4 above shall apply.
//
// 6. Nothing contained herein shall be construed as by implication, estoppels
//    or otherwise:
//    (a) conferring any license or right to use MStar name, trademark, service
//        mark, symbol or any other identification;
//    (b) obligating MStar or any of its affiliates to furnish any person,
//        including without limitation, you and your customers, any assistance
//        of any kind whatsoever, or any information; or
//    (c) conferring any license or right under any intellectual property right.
//
// 7. These terms shall be governed by and construed in accordance with the laws
//    of Taiwan, R.O.C., excluding its conflict of law rules.
//    Any and all dispute arising out hereof or related hereto shall be finally
//    settled by arbitration referred to the Chinese Arbitration Association,
//    Taipei in accordance with the ROC Arbitration Law and the Arbitration
//    Rules of the Association by three (3) arbitrators appointed in accordance
//    with the said Rules.
//    The place of arbitration shall be in Taipei, Taiwan and the language shall
//    be English.
//    The arbitration award shall be final and binding to both parties.
//


/******************************/
/*         VARIABLES          */
/******************************/
#include "msAPI_MLE_bidi_priv.h"
#include "msAPI_MLE_text_util.h"
#define _RET_IF_NULL(ptr) if(NULL == ptr) return FALSE

#ifdef __BIDI_TEXT__
//#define __BIDI_TEST__ 1

#ifndef __BIDI_TEST__
__SLDPM_FREE__ static const U8 _g_nBidiTypesFromChar[] =
{
         //0         1        2        3        4        5        6        7        8        9        a        b        c        d        e         f
/*00-0f*/  BIDI_BN,  BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_S,  BIDI_B,  BIDI_S,  BIDI_WS, BIDI_B,  BIDI_BN, BIDI_BN,
/*10-1f*/  BIDI_BN,  BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_B,  BIDI_B,  BIDI_B,  BIDI_S,
/*20-2f*/  BIDI_WS,  BIDI_ON, BIDI_ON, BIDI_ET, BIDI_ET, BIDI_ET, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ES, BIDI_CS, BIDI_ES, BIDI_CS, BIDI_CS,
/*30-3f*/  BIDI_EN,  BIDI_EN, BIDI_EN, BIDI_EN, BIDI_EN, BIDI_EN, BIDI_EN, BIDI_EN, BIDI_EN, BIDI_EN, BIDI_CS, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON,
/*40-4f*/  BIDI_ON,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,
/*50-5f*/  BIDI_L,   BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON,
/*60-6f*/  BIDI_NSM, BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,
/*70-7f*/  BIDI_L,   BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_BN,
/*80-8f*/  BIDI_BN,  BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_B,  BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN,
/*90-9f*/  BIDI_BN,  BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN,
/*a0-af*/  BIDI_CS,  BIDI_ON, BIDI_ET, BIDI_ET, BIDI_ET, BIDI_ET, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_L,  BIDI_ON, BIDI_ON, BIDI_BN, BIDI_ON, BIDI_ON,
/*b0-bf*/  BIDI_ET,  BIDI_ET, BIDI_EN, BIDI_EN, BIDI_ON, BIDI_L,  BIDI_ON, BIDI_ON, BIDI_ON, BIDI_EN, BIDI_L,  BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON,
/*c0-cf*/  BIDI_L,   BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,
/*d0-df*/  BIDI_L,   BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_ON, BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,
/*e0-ef*/  BIDI_L,   BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,
/*f0-ff*/  BIDI_L,   BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_ON, BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L
};
#else
static const U8 _g_nBidiTypesFromChar[] =
{
         //0         1        2        3        4        5        6        7        8        9        a        b        c        d        e        f
/*00-0f*/  BIDI_BN,  BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_S,  BIDI_B,  BIDI_S,  BIDI_WS, BIDI_B,  BIDI_BN, BIDI_BN,
/*10-1f*/  BIDI_BN,  BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_B,  BIDI_B,  BIDI_B,  BIDI_S,
/*20-2f*/  BIDI_WS,  BIDI_ON, BIDI_ON, BIDI_ET, BIDI_ET, BIDI_ET, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ES, BIDI_CS, BIDI_ES, BIDI_CS, BIDI_CS,
/*30-3f*/  BIDI_EN,  BIDI_EN, BIDI_EN, BIDI_EN, BIDI_EN, BIDI_EN, BIDI_EN, BIDI_EN, BIDI_EN, BIDI_EN, BIDI_CS, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON,
/*40-4f*/  BIDI_ON,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,
/*50-5f*/  BIDI_R,   BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_R,  BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON,
/*60-6f*/  BIDI_NSM, BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,
/*70-7f*/  BIDI_L,   BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_BN,
/*80-8f*/  BIDI_BN,  BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_B,  BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN,
/*90-9f*/  BIDI_BN,  BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN, BIDI_BN,
/*a0-af*/  BIDI_CS,  BIDI_ON, BIDI_ET, BIDI_ET, BIDI_ET, BIDI_ET, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_L,  BIDI_ON, BIDI_ON, BIDI_BN, BIDI_ON, BIDI_ON,
/*b0-bf*/  BIDI_ET,  BIDI_ET, BIDI_EN, BIDI_EN, BIDI_ON, BIDI_L,  BIDI_ON, BIDI_ON, BIDI_ON, BIDI_EN, BIDI_L,  BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON, BIDI_ON,
/*c0-cf*/  BIDI_L,   BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,
/*d0-df*/  BIDI_L,   BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_ON, BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,
/*e0-ef*/  BIDI_L,   BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,
/*f0-ff*/  BIDI_L,   BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_ON, BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L,  BIDI_L
};
#endif //__BIDI_TEST__

// WS, LS and S are not explicitly needed except for L1. Therefore this
// Table conflates ON, S, WS, and LS to N, all others unchanged
__SLDPM_FREE__ static const U8 _g_nBidiNTypes[] = {
    BIDI_N,      // ON,
    BIDI_L,      // L,
    BIDI_R,      // R,
    BIDI_AN,     // AN,
    BIDI_EN,     // EN,
    BIDI_AL,     // AL
    BIDI_NSM,    // NSM
    BIDI_CS,     // CS
    BIDI_ES,     // ES
    BIDI_ET,     // ET
    BIDI_BN,     // BN
    BIDI_N,      // S
    BIDI_N,      // WS
    BIDI_B,      // B
    BIDI_RLO,    // RLO
    BIDI_RLE,    // RLE
    BIDI_LRO,    // LRO
    BIDI_LRE,    // LRE
    BIDI_PDF,    // PDF
    BIDI_ON,     // LS
};

static const U8 _g_nBidiStateWeak[20][10] = {
                          //  BIDI_N        BIDI_L        BIDI_R        BIDI_AN       BIDI_EN       BIDI_AL       BIDI_NSM       BIDI_CS       BIDI_ES       BIDI_ET,
{/*BIDI_WEAK_XA*/  BIDI_WEAK_AO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_CN, BIDI_WEAK_CN, BIDI_WEAK_XA, BIDI_WEAK_XA,  BIDI_WEAK_AO, BIDI_WEAK_AO, BIDI_WEAK_AO,  /* arabic letter */},
{/*BIDI_WEAK_XR*/  BIDI_WEAK_RO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_RA, BIDI_WEAK_RE, BIDI_WEAK_XA, BIDI_WEAK_XR,  BIDI_WEAK_RO, BIDI_WEAK_RO, BIDI_WEAK_RT,  /* right letter */},
{/*BIDI_WEAK_XL*/  BIDI_WEAK_LO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_LA, BIDI_WEAK_LE, BIDI_WEAK_XA, BIDI_WEAK_XL,  BIDI_WEAK_LO, BIDI_WEAK_LO, BIDI_WEAK_LT,  /* left letter */},

{/*BIDI_WEAK_AO*/  BIDI_WEAK_AO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_CN, BIDI_WEAK_CN, BIDI_WEAK_XA, BIDI_WEAK_AO,  BIDI_WEAK_AO, BIDI_WEAK_AO, BIDI_WEAK_AO,  /* arabic letter foll by ON */},
{/*BIDI_WEAK_RO*/  BIDI_WEAK_RO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_RA, BIDI_WEAK_RE, BIDI_WEAK_XA, BIDI_WEAK_RO,  BIDI_WEAK_RO, BIDI_WEAK_RO, BIDI_WEAK_RT,  /* right letter foll by ON */},
{/*BIDI_WEAK_LO*/  BIDI_WEAK_LO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_LA, BIDI_WEAK_LE, BIDI_WEAK_XA, BIDI_WEAK_LO,  BIDI_WEAK_LO, BIDI_WEAK_LO, BIDI_WEAK_LT,  /* left letter foll by ON */},

{/*BIDI_WEAK_RT*/  BIDI_WEAK_RO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_RA, BIDI_WEAK_RE, BIDI_WEAK_XA, BIDI_WEAK_RT,  BIDI_WEAK_RO, BIDI_WEAK_RO, BIDI_WEAK_RT,  /* ET following R */},
{/*BIDI_WEAK_LT*/  BIDI_WEAK_LO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_LA, BIDI_WEAK_LE, BIDI_WEAK_XA, BIDI_WEAK_LT,  BIDI_WEAK_LO, BIDI_WEAK_LO, BIDI_WEAK_LT,  /* ET following L */},

{/*BIDI_WEAK_CN*/  BIDI_WEAK_AO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_CN, BIDI_WEAK_CN, BIDI_WEAK_XA, BIDI_WEAK_CN,  BIDI_WEAK_AC, BIDI_WEAK_AO, BIDI_WEAK_AO,  /* EN, AN following AL */},
{/*BIDI_WEAK_RA*/  BIDI_WEAK_RO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_RA, BIDI_WEAK_RE, BIDI_WEAK_XA, BIDI_WEAK_RA,  BIDI_WEAK_RC, BIDI_WEAK_RO, BIDI_WEAK_RT,  /* arabic number foll R */},
{/*BIDI_WEAK_RE*/  BIDI_WEAK_RO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_RA, BIDI_WEAK_RE, BIDI_WEAK_XA, BIDI_WEAK_RE,  BIDI_WEAK_RS, BIDI_WEAK_RS, BIDI_WEAK_RET, /* european number foll R */},
{/*BIDI_WEAK_LA*/  BIDI_WEAK_LO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_LA, BIDI_WEAK_LE, BIDI_WEAK_XA, BIDI_WEAK_LA,  BIDI_WEAK_LC, BIDI_WEAK_LO, BIDI_WEAK_LT,  /* arabic number foll L */},
{/*BIDI_WEAK_LE*/  BIDI_WEAK_LO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_LA, BIDI_WEAK_LE, BIDI_WEAK_XA, BIDI_WEAK_LE,  BIDI_WEAK_LS, BIDI_WEAK_LS, BIDI_WEAK_LET, /* european number foll L */},

{/*BIDI_WEAK_AC*/  BIDI_WEAK_AO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_CN, BIDI_WEAK_CN, BIDI_WEAK_XA, BIDI_WEAK_AO,  BIDI_WEAK_AO, BIDI_WEAK_AO, BIDI_WEAK_AO,  /* CS following cn */},
{/*BIDI_WEAK_RC*/  BIDI_WEAK_RO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_RA, BIDI_WEAK_RE, BIDI_WEAK_XA, BIDI_WEAK_RO,  BIDI_WEAK_RO, BIDI_WEAK_RO, BIDI_WEAK_RT,  /* CS following ra */},
{/*BIDI_WEAK_RS*/  BIDI_WEAK_RO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_RA, BIDI_WEAK_RE, BIDI_WEAK_XA, BIDI_WEAK_RO,  BIDI_WEAK_RO, BIDI_WEAK_RO, BIDI_WEAK_RT,  /* CS,ES following re */},
{/*BIDI_WEAK_LC*/  BIDI_WEAK_LO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_LA, BIDI_WEAK_LE, BIDI_WEAK_XA, BIDI_WEAK_LO,  BIDI_WEAK_LO, BIDI_WEAK_LO, BIDI_WEAK_LT,  /* CS following la */},
{/*BIDI_WEAK_LS*/  BIDI_WEAK_LO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_LA, BIDI_WEAK_LE, BIDI_WEAK_XA, BIDI_WEAK_LO,  BIDI_WEAK_LO, BIDI_WEAK_LO, BIDI_WEAK_LT,  /* CS,ES following le */},

{/*BIDI_WEAK_RET*/ BIDI_WEAK_RO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_RA, BIDI_WEAK_RE, BIDI_WEAK_XA, BIDI_WEAK_RET, BIDI_WEAK_RO, BIDI_WEAK_RO, BIDI_WEAK_RET, /* ET following re */},
{/*BIDI_WEAK_LET*/ BIDI_WEAK_LO, BIDI_WEAK_XL, BIDI_WEAK_XR, BIDI_WEAK_LA, BIDI_WEAK_LE, BIDI_WEAK_XA, BIDI_WEAK_LET, BIDI_WEAK_LO, BIDI_WEAK_LO, BIDI_WEAK_LET  /* ET following le */}
};

static const U16 _g_nBidiActionWeak[20][10] = {
              //  BIDI_N             BIDI_L             BIDI_R             BIDI_AN            BIDI_EN            BIDI_AL            BIDI_NSM           BIDI_CS            BIDI_ES            BIDI_ET
{/*BIDI_WEAK_XA*/  BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXA, BIDI_WEAK_ACT_XXR, BIDI_WEAK_ACT_XXR, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XXN, /* arabic letter */},
{/*BIDI_WEAK_XR*/  BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXE, BIDI_WEAK_ACT_XXR, BIDI_WEAK_ACT_XXR, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XIX, /* right letter */},
{/*BIDI_WEAK_XL*/  BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXL, BIDI_WEAK_ACT_XXR, BIDI_WEAK_ACT_XXL, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XIX, /* left letter */},

{/*BIDI_WEAK_AO*/  BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXA, BIDI_WEAK_ACT_XXR, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XXN, /* arabic letter foll by ON */},
{/*BIDI_WEAK_RO*/  BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXE, BIDI_WEAK_ACT_XXR, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XIX, /* right letter foll by ON */},
{/*BIDI_WEAK_LO*/  BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXL, BIDI_WEAK_ACT_XXR, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XIX, /* left letter foll by ON */},

{/*BIDI_WEAK_RT*/  BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_EXE, BIDI_WEAK_ACT_NXR, BIDI_WEAK_ACT_XIX, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_XIX, /* ET following R */},
{/*BIDI_WEAK_LT*/  BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_LXL, BIDI_WEAK_ACT_NXR, BIDI_WEAK_ACT_XIX, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_XIX, /* ET following L */},

{/*BIDI_WEAK_CN*/  BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXA, BIDI_WEAK_ACT_XXR, BIDI_WEAK_ACT_XXA, BIDI_WEAK_ACT_XIX, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XXN, /* EN, AN following AL */},
{/*BIDI_WEAK_RA*/  BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXE, BIDI_WEAK_ACT_XXR, BIDI_WEAK_ACT_XXA, BIDI_WEAK_ACT_XIX, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XIX, /* arabic number foll R */},
{/*BIDI_WEAK_RE*/  BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXE, BIDI_WEAK_ACT_XXR, BIDI_WEAK_ACT_XXE, BIDI_WEAK_ACT_XIX, BIDI_WEAK_ACT_XIX, BIDI_WEAK_ACT_XXE, /* european number foll R */},
{/*BIDI_WEAK_LA*/  BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXL, BIDI_WEAK_ACT_XXR, BIDI_WEAK_ACT_XXA, BIDI_WEAK_ACT_XIX, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XIX, /* arabic number foll L */},
{/*BIDI_WEAK_LE*/  BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXL, BIDI_WEAK_ACT_XXR, BIDI_WEAK_ACT_XXL, BIDI_WEAK_ACT_XIX, BIDI_WEAK_ACT_XIX, BIDI_WEAK_ACT_XXL, /* european number foll L */},

{/*BIDI_WEAK_AC*/  BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_AXX, BIDI_WEAK_ACT_AXA, BIDI_WEAK_ACT_NXR, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_NXN, /* CS following cn */},
{/*BIDI_WEAK_RC*/  BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_AXX, BIDI_WEAK_ACT_NXE, BIDI_WEAK_ACT_NXR, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_NIX, /* CS following ra */},
{/*BIDI_WEAK_RS*/  BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_EXE, BIDI_WEAK_ACT_NXR, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_NIX, /* CS,ES following re */},
{/*BIDI_WEAK_LC*/  BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_AXX, BIDI_WEAK_ACT_NXL, BIDI_WEAK_ACT_NXR, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_NIX, /* CS following la */},
{/*BIDI_WEAK_LS*/  BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_NXX, BIDI_WEAK_ACT_LXL, BIDI_WEAK_ACT_NXR, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_NXN, BIDI_WEAK_ACT_NIX, /* CS,ES following le */},

{/*BIDI_WEAK_RET*/ BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXE, BIDI_WEAK_ACT_XXR, BIDI_WEAK_ACT_XXE, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XXE, /* ET following re */},
{/*BIDI_WEAK_LET*/ BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXX, BIDI_WEAK_ACT_XXL, BIDI_WEAK_ACT_XXR, BIDI_WEAK_ACT_XXL, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XXN, BIDI_WEAK_ACT_XXL  /* ET following le */}
};

static const U8 _g_nBidiStateNeutrals[6][5] = {
                //  BIDI_N           BIDI_L           BIDI_R           BIDI_AN          BIDI_EN
{/*BIDI_NEUTRAL_R*/  BIDI_NEUTRAL_RN, BIDI_NEUTRAL_L,  BIDI_NEUTRAL_R,  BIDI_NEUTRAL_R,  BIDI_NEUTRAL_R,},
{/*BIDI_NEUTRAL_L*/  BIDI_NEUTRAL_LN, BIDI_NEUTRAL_L,  BIDI_NEUTRAL_R,  BIDI_NEUTRAL_A,  BIDI_NEUTRAL_L,},
{/*BIDI_NEUTRAL_RN*/ BIDI_NEUTRAL_RN, BIDI_NEUTRAL_L,  BIDI_NEUTRAL_R,  BIDI_NEUTRAL_R,  BIDI_NEUTRAL_R,},
{/*BIDI_NEUTRAL_LN*/ BIDI_NEUTRAL_LN, BIDI_NEUTRAL_L,  BIDI_NEUTRAL_R,  BIDI_NEUTRAL_A,  BIDI_NEUTRAL_L,},
{/*BIDI_NEUTRAL_A*/  BIDI_NEUTRAL_NA, BIDI_NEUTRAL_L,  BIDI_NEUTRAL_R,  BIDI_NEUTRAL_A,  BIDI_NEUTRAL_L,},
{/*BIDI_NEUTRAL_NA*/ BIDI_NEUTRAL_NA, BIDI_NEUTRAL_L,  BIDI_NEUTRAL_R,  BIDI_NEUTRAL_A,  BIDI_NEUTRAL_L}
};

static const U16 _g_nBidiActionNeutrals[6][5] = {
                //  BIDI_N               BIDI_L               BIDI_R               BIDI_AN              BIDI_EN
{/*BIDI_NEUTRAL_R*/  BIDI_NEUTRAL_ACT_IN, BIDI_N,              BIDI_N,              BIDI_N,              BIDI_N,},
{/*BIDI_NEUTRAL_L*/  BIDI_NEUTRAL_ACT_IN, BIDI_N,              BIDI_N,              BIDI_N,              BIDI_NEUTRAL_L,},
{/*BIDI_NEUTRAL_RN*/ BIDI_NEUTRAL_ACT_IN, BIDI_NEUTRAL_ACT_EN, BIDI_NEUTRAL_ACT_RN, BIDI_NEUTRAL_ACT_RN, BIDI_NEUTRAL_ACT_RN,},
{/*BIDI_NEUTRAL_LN*/ BIDI_NEUTRAL_ACT_IN, BIDI_NEUTRAL_ACT_LN, BIDI_NEUTRAL_ACT_EN, BIDI_NEUTRAL_ACT_EN, BIDI_NEUTRAL_ACT_LNL,},
{/*BIDI_NEUTRAL_A*/  BIDI_NEUTRAL_ACT_IN, BIDI_N,              BIDI_N,              BIDI_N,              BIDI_NEUTRAL_L,},
{/*BIDI_NEUTRAL_NA*/ BIDI_NEUTRAL_ACT_IN, BIDI_NEUTRAL_ACT_EN, BIDI_NEUTRAL_ACT_RN, BIDI_NEUTRAL_ACT_RN, BIDI_NEUTRAL_ACT_EN}
};

static const U8 _g_nBidiAddLevel[2][4] = {
        // L,  R,  AN, EN
{/* even */ 0,  1,  2,  2,  },// EVEN
{/* odd  */ 1,  0,  1,  1   }// ODD
};

static const U16 _g_nMirrors[][2] =
{
    {0x0028, 0x0029}, //LEFT PARENTHESIS
    {0x0029, 0x0028}, //RIGHT PARENTHESIS
    {0x003C, 0x003E}, //LESS-THAN SIGN
    {0x003E, 0x003C}, //GREATER-THAN SIGN
    {0x005B, 0x005D}, //LEFT SQUARE BRACKET
    {0x005D, 0x005B}, //RIGHT SQUARE BRACKET
    {0x007B, 0x007D}, //LEFT CURLY BRACKET
    {0x007D, 0x007B}, //RIGHT CURLY BRACKET
    {0x00AB, 0x00BB}, //LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    {0x00BB, 0x00AB}, //RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    {0x0F3A, 0x0F3B}, //TIBETAN MARK GUG RTAGS GYON
    {0x0F3B, 0x0F3A}, //TIBETAN MARK GUG RTAGS GYAS
    {0x0F3C, 0x0F3D}, //TIBETAN MARK ANG KHANG GYON
    {0x0F3D, 0x0F3C}, //TIBETAN MARK ANG KHANG GYAS
    {0x169B, 0x169C}, //OGHAM FEATHER MARK
    {0x169C, 0x169B}, //OGHAM REVERSED FEATHER MARK
    {0x2039, 0x203A}, //SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    {0x203A, 0x2039}, //SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    {0x2045, 0x2046}, //LEFT SQUARE BRACKET WITH QUILL
    {0x2046, 0x2045}, //RIGHT SQUARE BRACKET WITH QUILL
    {0x207D, 0x207E}, //SUPERSCRIPT LEFT PARENTHESIS
    {0x207E, 0x207D}, //SUPERSCRIPT RIGHT PARENTHESIS
    {0x208D, 0x208E}, //SUBSCRIPT LEFT PARENTHESIS
    {0x208E, 0x208D}, //SUBSCRIPT RIGHT PARENTHESIS
    {0x2208, 0x220B}, //ELEMENT OF
    {0x2209, 0x220C}, //NOT AN ELEMENT OF
    {0x220A, 0x220D}, //SMALL ELEMENT OF
    {0x220B, 0x2208}, //CONTAINS AS MEMBER
    {0x220C, 0x2209}, //DOES NOT CONTAIN AS MEMBER
    {0x220D, 0x220A}, //SMALL CONTAINS AS MEMBER
    {0x2215, 0x29F5}, //DIVISION SLASH
    {0x223C, 0x223D}, //TILDE OPERATOR
    {0x223D, 0x223C}, //REVERSED TILDE
    {0x2243, 0x22CD}, //ASYMPTOTICALLY EQUAL TO
    {0x2252, 0x2253}, //APPROXIMATELY EQUAL TO OR THE IMAGE OF
    {0x2253, 0x2252}, //IMAGE OF OR APPROXIMATELY EQUAL TO
    {0x2254, 0x2255}, //COLON EQUALS
    {0x2255, 0x2254}, //EQUALS COLON
    {0x2264, 0x2265}, //LESS-THAN OR EQUAL TO
    {0x2265, 0x2264}, //GREATER-THAN OR EQUAL TO
    {0x2266, 0x2267}, //LESS-THAN OVER EQUAL TO
    {0x2267, 0x2266}, //GREATER-THAN OVER EQUAL TO
    {0x2268, 0x2269}, //[BEST FIT] LESS-THAN BUT NOT EQUAL TO
    {0x2269, 0x2268}, //[BEST FIT] GREATER-THAN BUT NOT EQUAL TO
    {0x226A, 0x226B}, //MUCH LESS-THAN
    {0x226B, 0x226A}, //MUCH GREATER-THAN
    {0x226E, 0x226F}, //[BEST FIT] NOT LESS-THAN
    {0x226F, 0x226E}, //[BEST FIT] NOT GREATER-THAN
    {0x2270, 0x2271}, //[BEST FIT] NEITHER LESS-THAN NOR EQUAL TO
    {0x2271, 0x2270}, //[BEST FIT] NEITHER GREATER-THAN NOR EQUAL TO
    {0x2272, 0x2273}, //[BEST FIT] LESS-THAN OR EQUIVALENT TO
    {0x2273, 0x2272}, //[BEST FIT] GREATER-THAN OR EQUIVALENT TO
    {0x2274, 0x2275}, //[BEST FIT] NEITHER LESS-THAN NOR EQUIVALENT TO
    {0x2275, 0x2274}, //[BEST FIT] NEITHER GREATER-THAN NOR EQUIVALENT TO
    {0x2276, 0x2277}, //LESS-THAN OR GREATER-THAN
    {0x2277, 0x2276}, //GREATER-THAN OR LESS-THAN
    {0x2278, 0x2279}, //[BEST FIT] NEITHER LESS-THAN NOR GREATER-THAN
    {0x2279, 0x2278}, //[BEST FIT] NEITHER GREATER-THAN NOR LESS-THAN
    {0x227A, 0x227B}, //PRECEDES
    {0x227B, 0x227A}, //SUCCEEDS
    {0x227C, 0x227D}, //PRECEDES OR EQUAL TO
    {0x227D, 0x227C}, //SUCCEEDS OR EQUAL TO
    {0x227E, 0x227F}, //[BEST FIT] PRECEDES OR EQUIVALENT TO
    {0x227F, 0x227E}, //[BEST FIT] SUCCEEDS OR EQUIVALENT TO
    {0x2280, 0x2281}, //[BEST FIT] DOES NOT PRECEDE
    {0x2281, 0x2280}, //[BEST FIT] DOES NOT SUCCEED
    {0x2282, 0x2283}, //SUBSET OF
    {0x2283, 0x2282}, //SUPERSET OF
    {0x2284, 0x2285}, //[BEST FIT] NOT A SUBSET OF
    {0x2285, 0x2284}, //[BEST FIT] NOT A SUPERSET OF
    {0x2286, 0x2287}, //SUBSET OF OR EQUAL TO
    {0x2287, 0x2286}, //SUPERSET OF OR EQUAL TO
    {0x2288, 0x2289}, //[BEST FIT] NEITHER A SUBSET OF NOR EQUAL TO
    {0x2289, 0x2288}, //[BEST FIT] NEITHER A SUPERSET OF NOR EQUAL TO
    {0x228A, 0x228B}, //[BEST FIT] SUBSET OF WITH NOT EQUAL TO
    {0x228B, 0x228A}, //[BEST FIT] SUPERSET OF WITH NOT EQUAL TO
    {0x228F, 0x2290}, //SQUARE IMAGE OF
    {0x2290, 0x228F}, //SQUARE ORIGINAL OF
    {0x2291, 0x2292}, //SQUARE IMAGE OF OR EQUAL TO
    {0x2292, 0x2291}, //SQUARE ORIGINAL OF OR EQUAL TO
    {0x2298, 0x29B8}, //CIRCLED DIVISION SLASH
    {0x22A2, 0x22A3}, //RIGHT TACK
    {0x22A3, 0x22A2}, //LEFT TACK
    {0x22A6, 0x2ADE}, //ASSERTION
    {0x22A8, 0x2AE4}, //TRUE
    {0x22A9, 0x2AE3}, //FORCES
    {0x22AB, 0x2AE5}, //DOUBLE VERTICAL BAR DOUBLE RIGHT TURNSTILE
    {0x22B0, 0x22B1}, //PRECEDES UNDER RELATION
    {0x22B1, 0x22B0}, //SUCCEEDS UNDER RELATION
    {0x22B2, 0x22B3}, //NORMAL SUBGROUP OF
    {0x22B3, 0x22B2}, //CONTAINS AS NORMAL SUBGROUP
    {0x22B4, 0x22B5}, //NORMAL SUBGROUP OF OR EQUAL TO
    {0x22B5, 0x22B4}, //CONTAINS AS NORMAL SUBGROUP OR EQUAL TO
    {0x22B6, 0x22B7}, //ORIGINAL OF
    {0x22B7, 0x22B6}, //IMAGE OF
    {0x22C9, 0x22CA}, //LEFT NORMAL FACTOR SEMIDIRECT PRODUCT
    {0x22CA, 0x22C9}, //RIGHT NORMAL FACTOR SEMIDIRECT PRODUCT
    {0x22CB, 0x22CC}, //LEFT SEMIDIRECT PRODUCT
    {0x22CC, 0x22CB}, //RIGHT SEMIDIRECT PRODUCT
    {0x22CD, 0x2243}, //REVERSED TILDE EQUALS
    {0x22D0, 0x22D1}, //DOUBLE SUBSET
    {0x22D1, 0x22D0}, //DOUBLE SUPERSET
    {0x22D6, 0x22D7}, //LESS-THAN WITH DOT
    {0x22D7, 0x22D6}, //GREATER-THAN WITH DOT
    {0x22D8, 0x22D9}, //VERY MUCH LESS-THAN
    {0x22D9, 0x22D8}, //VERY MUCH GREATER-THAN
    {0x22DA, 0x22DB}, //LESS-THAN EQUAL TO OR GREATER-THAN
    {0x22DB, 0x22DA}, //GREATER-THAN EQUAL TO OR LESS-THAN
    {0x22DC, 0x22DD}, //EQUAL TO OR LESS-THAN
    {0x22DD, 0x22DC}, //EQUAL TO OR GREATER-THAN
    {0x22DE, 0x22DF}, //EQUAL TO OR PRECEDES
    {0x22DF, 0x22DE}, //EQUAL TO OR SUCCEEDS
    {0x22E0, 0x22E1}, //[BEST FIT] DOES NOT PRECEDE OR EQUAL
    {0x22E1, 0x22E0}, //[BEST FIT] DOES NOT SUCCEED OR EQUAL
    {0x22E2, 0x22E3}, //[BEST FIT] NOT SQUARE IMAGE OF OR EQUAL TO
    {0x22E3, 0x22E2}, //[BEST FIT] NOT SQUARE ORIGINAL OF OR EQUAL TO
    {0x22E4, 0x22E5}, //[BEST FIT] SQUARE IMAGE OF OR NOT EQUAL TO
    {0x22E5, 0x22E4}, //[BEST FIT] SQUARE ORIGINAL OF OR NOT EQUAL TO
    {0x22E6, 0x22E7}, //[BEST FIT] LESS-THAN BUT NOT EQUIVALENT TO
    {0x22E7, 0x22E6}, //[BEST FIT] GREATER-THAN BUT NOT EQUIVALENT TO
    {0x22E8, 0x22E9}, //[BEST FIT] PRECEDES BUT NOT EQUIVALENT TO
    {0x22E9, 0x22E8}, //[BEST FIT] SUCCEEDS BUT NOT EQUIVALENT TO
    {0x22EA, 0x22EB}, //[BEST FIT] NOT NORMAL SUBGROUP OF
    {0x22EB, 0x22EA}, //[BEST FIT] DOES NOT CONTAIN AS NORMAL SUBGROUP
    {0x22EC, 0x22ED}, //[BEST FIT] NOT NORMAL SUBGROUP OF OR EQUAL TO
    {0x22ED, 0x22EC}, //[BEST FIT] DOES NOT CONTAIN AS NORMAL SUBGROUP OR EQUAL
    {0x22F0, 0x22F1}, //UP RIGHT DIAGONAL ELLIPSIS
    {0x22F1, 0x22F0}, //DOWN RIGHT DIAGONAL ELLIPSIS
    {0x22F2, 0x22FA}, //ELEMENT OF WITH LONG HORIZONTAL STROKE
    {0x22F3, 0x22FB}, //ELEMENT OF WITH VERTICAL BAR AT END OF HORIZONTAL STROKE
    {0x22F4, 0x22FC}, //SMALL ELEMENT OF WITH VERTICAL BAR AT END OF HORIZONTAL STROKE
    {0x22F6, 0x22FD}, //ELEMENT OF WITH OVERBAR
    {0x22F7, 0x22FE}, //SMALL ELEMENT OF WITH OVERBAR
    {0x22FA, 0x22F2}, //CONTAINS WITH LONG HORIZONTAL STROKE
    {0x22FB, 0x22F3}, //CONTAINS WITH VERTICAL BAR AT END OF HORIZONTAL STROKE
    {0x22FC, 0x22F4}, //SMALL CONTAINS WITH VERTICAL BAR AT END OF HORIZONTAL STROKE
    {0x22FD, 0x22F6}, //CONTAINS WITH OVERBAR
    {0x22FE, 0x22F7}, //SMALL CONTAINS WITH OVERBAR
    {0x2308, 0x2309}, //LEFT CEILING
    {0x2309, 0x2308}, //RIGHT CEILING
    {0x230A, 0x230B}, //LEFT FLOOR
    {0x230B, 0x230A}, //RIGHT FLOOR
    {0x2329, 0x232A}, //LEFT-POINTING ANGLE BRACKET
    {0x232A, 0x2329}, //RIGHT-POINTING ANGLE BRACKET
    {0x2768, 0x2769}, //MEDIUM LEFT PARENTHESIS ORNAMENT
    {0x2769, 0x2768}, //MEDIUM RIGHT PARENTHESIS ORNAMENT
    {0x276A, 0x276B}, //MEDIUM FLATTENED LEFT PARENTHESIS ORNAMENT
    {0x276B, 0x276A}, //MEDIUM FLATTENED RIGHT PARENTHESIS ORNAMENT
    {0x276C, 0x276D}, //MEDIUM LEFT-POINTING ANGLE BRACKET ORNAMENT
    {0x276D, 0x276C}, //MEDIUM RIGHT-POINTING ANGLE BRACKET ORNAMENT
    {0x276E, 0x276F}, //HEAVY LEFT-POINTING ANGLE QUOTATION MARK ORNAMENT
    {0x276F, 0x276E}, //HEAVY RIGHT-POINTING ANGLE QUOTATION MARK ORNAMENT
    {0x2770, 0x2771}, //HEAVY LEFT-POINTING ANGLE BRACKET ORNAMENT
    {0x2771, 0x2770}, //HEAVY RIGHT-POINTING ANGLE BRACKET ORNAMENT
    {0x2772, 0x2773}, //LIGHT LEFT TORTOISE SHELL BRACKET
    {0x2773, 0x2772}, //LIGHT RIGHT TORTOISE SHELL BRACKET
    {0x2774, 0x2775}, //MEDIUM LEFT CURLY BRACKET ORNAMENT
    {0x2775, 0x2774}, //MEDIUM RIGHT CURLY BRACKET ORNAMENT
    {0x27C3, 0x27C4}, //OPEN SUBSET
    {0x27C4, 0x27C3}, //OPEN SUPERSET
    {0x27C5, 0x27C6}, //LEFT S-SHAPED BAG DELIMITER
    {0x27C6, 0x27C5}, //RIGHT S-SHAPED BAG DELIMITER
    {0x27C8, 0x27C9}, //REVERSE SOLIDUS PRECEDING SUBSET
    {0x27C9, 0x27C8}, //SUPERSET PRECEDING SOLIDUS
    {0x27D5, 0x27D6}, //LEFT OUTER JOIN
    {0x27D6, 0x27D5}, //RIGHT OUTER JOIN
    {0x27DD, 0x27DE}, //LONG RIGHT TACK
    {0x27DE, 0x27DD}, //LONG LEFT TACK
    {0x27E2, 0x27E3}, //WHITE CONCAVE-SIDED DIAMOND WITH LEFTWARDS TICK
    {0x27E3, 0x27E2}, //WHITE CONCAVE-SIDED DIAMOND WITH RIGHTWARDS TICK
    {0x27E4, 0x27E5}, //WHITE SQUARE WITH LEFTWARDS TICK
    {0x27E5, 0x27E4}, //WHITE SQUARE WITH RIGHTWARDS TICK
    {0x27E6, 0x27E7}, //MATHEMATICAL LEFT WHITE SQUARE BRACKET
    {0x27E7, 0x27E6}, //MATHEMATICAL RIGHT WHITE SQUARE BRACKET
    {0x27E8, 0x27E9}, //MATHEMATICAL LEFT ANGLE BRACKET
    {0x27E9, 0x27E8}, //MATHEMATICAL RIGHT ANGLE BRACKET
    {0x27EA, 0x27EB}, //MATHEMATICAL LEFT DOUBLE ANGLE BRACKET
    {0x27EB, 0x27EA}, //MATHEMATICAL RIGHT DOUBLE ANGLE BRACKET
    {0x27EC, 0x27ED}, //MATHEMATICAL LEFT WHITE TORTOISE SHELL BRACKET
    {0x27ED, 0x27EC}, //MATHEMATICAL RIGHT WHITE TORTOISE SHELL BRACKET
    {0x27EE, 0x27EF}, //MATHEMATICAL LEFT FLATTENED PARENTHESIS
    {0x27EF, 0x27EE}, //MATHEMATICAL RIGHT FLATTENED PARENTHESIS
    {0x2983, 0x2984}, //LEFT WHITE CURLY BRACKET
    {0x2984, 0x2983}, //RIGHT WHITE CURLY BRACKET
    {0x2985, 0x2986}, //LEFT WHITE PARENTHESIS
    {0x2986, 0x2985}, //RIGHT WHITE PARENTHESIS
    {0x2987, 0x2988}, //Z NOTATION LEFT IMAGE BRACKET
    {0x2988, 0x2987}, //Z NOTATION RIGHT IMAGE BRACKET
    {0x2989, 0x298A}, //Z NOTATION LEFT BINDING BRACKET
    {0x298A, 0x2989}, //Z NOTATION RIGHT BINDING BRACKET
    {0x298B, 0x298C}, //LEFT SQUARE BRACKET WITH UNDERBAR
    {0x298C, 0x298B}, //RIGHT SQUARE BRACKET WITH UNDERBAR
    {0x298D, 0x2990}, //LEFT SQUARE BRACKET WITH TICK IN TOP CORNER
    {0x298E, 0x298F}, //RIGHT SQUARE BRACKET WITH TICK IN BOTTOM CORNER
    {0x298F, 0x298E}, //LEFT SQUARE BRACKET WITH TICK IN BOTTOM CORNER
    {0x2990, 0x298D}, //RIGHT SQUARE BRACKET WITH TICK IN TOP CORNER
    {0x2991, 0x2992}, //LEFT ANGLE BRACKET WITH DOT
    {0x2992, 0x2991}, //RIGHT ANGLE BRACKET WITH DOT
    {0x2993, 0x2994}, //LEFT ARC LESS-THAN BRACKET
    {0x2994, 0x2993}, //RIGHT ARC GREATER-THAN BRACKET
    {0x2995, 0x2996}, //DOUBLE LEFT ARC GREATER-THAN BRACKET
    {0x2996, 0x2995}, //DOUBLE RIGHT ARC LESS-THAN BRACKET
    {0x2997, 0x2998}, //LEFT BLACK TORTOISE SHELL BRACKET
    {0x2998, 0x2997}, //RIGHT BLACK TORTOISE SHELL BRACKET
    {0x29B8, 0x2298}, //CIRCLED REVERSE SOLIDUS
    {0x29C0, 0x29C1}, //CIRCLED LESS-THAN
    {0x29C1, 0x29C0}, //CIRCLED GREATER-THAN
    {0x29C4, 0x29C5}, //SQUARED RISING DIAGONAL SLASH
    {0x29C5, 0x29C4}, //SQUARED FALLING DIAGONAL SLASH
    {0x29CF, 0x29D0}, //LEFT TRIANGLE BESIDE VERTICAL BAR
    {0x29D0, 0x29CF}, //VERTICAL BAR BESIDE RIGHT TRIANGLE
    {0x29D1, 0x29D2}, //BOWTIE WITH LEFT HALF BLACK
    {0x29D2, 0x29D1}, //BOWTIE WITH RIGHT HALF BLACK
    {0x29D4, 0x29D5}, //TIMES WITH LEFT HALF BLACK
    {0x29D5, 0x29D4}, //TIMES WITH RIGHT HALF BLACK
    {0x29D8, 0x29D9}, //LEFT WIGGLY FENCE
    {0x29D9, 0x29D8}, //RIGHT WIGGLY FENCE
    {0x29DA, 0x29DB}, //LEFT DOUBLE WIGGLY FENCE
    {0x29DB, 0x29DA}, //RIGHT DOUBLE WIGGLY FENCE
    {0x29F5, 0x2215}, //REVERSE SOLIDUS OPERATOR
    {0x29F8, 0x29F9}, //BIG SOLIDUS
    {0x29F9, 0x29F8}, //BIG REVERSE SOLIDUS
    {0x29FC, 0x29FD}, //LEFT-POINTING CURVED ANGLE BRACKET
    {0x29FD, 0x29FC}, //RIGHT-POINTING CURVED ANGLE BRACKET
    {0x2A2B, 0x2A2C}, //MINUS SIGN WITH FALLING DOTS
    {0x2A2C, 0x2A2B}, //MINUS SIGN WITH RISING DOTS
    {0x2A2D, 0x2A2E}, //PLUS SIGN IN LEFT HALF CIRCLE
    {0x2A2E, 0x2A2D}, //PLUS SIGN IN RIGHT HALF CIRCLE
    {0x2A34, 0x2A35}, //MULTIPLICATION SIGN IN LEFT HALF CIRCLE
    {0x2A35, 0x2A34}, //MULTIPLICATION SIGN IN RIGHT HALF CIRCLE
    {0x2A3C, 0x2A3D}, //INTERIOR PRODUCT
    {0x2A3D, 0x2A3C}, //RIGHTHAND INTERIOR PRODUCT
    {0x2A64, 0x2A65}, //Z NOTATION DOMAIN ANTIRESTRICTION
    {0x2A65, 0x2A64}, //Z NOTATION RANGE ANTIRESTRICTION
    {0x2A79, 0x2A7A}, //LESS-THAN WITH CIRCLE INSIDE
    {0x2A7A, 0x2A79}, //GREATER-THAN WITH CIRCLE INSIDE
    {0x2A7D, 0x2A7E}, //LESS-THAN OR SLANTED EQUAL TO
    {0x2A7E, 0x2A7D}, //GREATER-THAN OR SLANTED EQUAL TO
    {0x2A7F, 0x2A80}, //LESS-THAN OR SLANTED EQUAL TO WITH DOT INSIDE
    {0x2A80, 0x2A7F}, //GREATER-THAN OR SLANTED EQUAL TO WITH DOT INSIDE
    {0x2A81, 0x2A82}, //LESS-THAN OR SLANTED EQUAL TO WITH DOT ABOVE
    {0x2A82, 0x2A81}, //GREATER-THAN OR SLANTED EQUAL TO WITH DOT ABOVE
    {0x2A83, 0x2A84}, //LESS-THAN OR SLANTED EQUAL TO WITH DOT ABOVE RIGHT
    {0x2A84, 0x2A83}, //GREATER-THAN OR SLANTED EQUAL TO WITH DOT ABOVE LEFT
    {0x2A8B, 0x2A8C}, //LESS-THAN ABOVE DOUBLE-LINE EQUAL ABOVE GREATER-THAN
    {0x2A8C, 0x2A8B}, //GREATER-THAN ABOVE DOUBLE-LINE EQUAL ABOVE LESS-THAN
    {0x2A91, 0x2A92}, //LESS-THAN ABOVE GREATER-THAN ABOVE DOUBLE-LINE EQUAL
    {0x2A92, 0x2A91}, //GREATER-THAN ABOVE LESS-THAN ABOVE DOUBLE-LINE EQUAL
    {0x2A93, 0x2A94}, //LESS-THAN ABOVE SLANTED EQUAL ABOVE GREATER-THAN ABOVE SLANTED EQUAL
    {0x2A94, 0x2A93}, //GREATER-THAN ABOVE SLANTED EQUAL ABOVE LESS-THAN ABOVE SLANTED EQUAL
    {0x2A95, 0x2A96}, //SLANTED EQUAL TO OR LESS-THAN
    {0x2A96, 0x2A95}, //SLANTED EQUAL TO OR GREATER-THAN
    {0x2A97, 0x2A98}, //SLANTED EQUAL TO OR LESS-THAN WITH DOT INSIDE
    {0x2A98, 0x2A97}, //SLANTED EQUAL TO OR GREATER-THAN WITH DOT INSIDE
    {0x2A99, 0x2A9A}, //DOUBLE-LINE EQUAL TO OR LESS-THAN
    {0x2A9A, 0x2A99}, //DOUBLE-LINE EQUAL TO OR GREATER-THAN
    {0x2A9B, 0x2A9C}, //DOUBLE-LINE SLANTED EQUAL TO OR LESS-THAN
    {0x2A9C, 0x2A9B}, //DOUBLE-LINE SLANTED EQUAL TO OR GREATER-THAN
    {0x2AA1, 0x2AA2}, //DOUBLE NESTED LESS-THAN
    {0x2AA2, 0x2AA1}, //DOUBLE NESTED GREATER-THAN
    {0x2AA6, 0x2AA7}, //LESS-THAN CLOSED BY CURVE
    {0x2AA7, 0x2AA6}, //GREATER-THAN CLOSED BY CURVE
    {0x2AA8, 0x2AA9}, //LESS-THAN CLOSED BY CURVE ABOVE SLANTED EQUAL
    {0x2AA9, 0x2AA8}, //GREATER-THAN CLOSED BY CURVE ABOVE SLANTED EQUAL
    {0x2AAA, 0x2AAB}, //SMALLER THAN
    {0x2AAB, 0x2AAA}, //LARGER THAN
    {0x2AAC, 0x2AAD}, //SMALLER THAN OR EQUAL TO
    {0x2AAD, 0x2AAC}, //LARGER THAN OR EQUAL TO
    {0x2AAF, 0x2AB0}, //PRECEDES ABOVE SINGLE-LINE EQUALS SIGN
    {0x2AB0, 0x2AAF}, //SUCCEEDS ABOVE SINGLE-LINE EQUALS SIGN
    {0x2AB3, 0x2AB4}, //PRECEDES ABOVE EQUALS SIGN
    {0x2AB4, 0x2AB3}, //SUCCEEDS ABOVE EQUALS SIGN
    {0x2ABB, 0x2ABC}, //DOUBLE PRECEDES
    {0x2ABC, 0x2ABB}, //DOUBLE SUCCEEDS
    {0x2ABD, 0x2ABE}, //SUBSET WITH DOT
    {0x2ABE, 0x2ABD}, //SUPERSET WITH DOT
    {0x2ABF, 0x2AC0}, //SUBSET WITH PLUS SIGN BELOW
    {0x2AC0, 0x2ABF}, //SUPERSET WITH PLUS SIGN BELOW
    {0x2AC1, 0x2AC2}, //SUBSET WITH MULTIPLICATION SIGN BELOW
    {0x2AC2, 0x2AC1}, //SUPERSET WITH MULTIPLICATION SIGN BELOW
    {0x2AC3, 0x2AC4}, //SUBSET OF OR EQUAL TO WITH DOT ABOVE
    {0x2AC4, 0x2AC3}, //SUPERSET OF OR EQUAL TO WITH DOT ABOVE
    {0x2AC5, 0x2AC6}, //SUBSET OF ABOVE EQUALS SIGN
    {0x2AC6, 0x2AC5}, //SUPERSET OF ABOVE EQUALS SIGN
    {0x2ACD, 0x2ACE}, //SQUARE LEFT OPEN BOX OPERATOR
    {0x2ACE, 0x2ACD}, //SQUARE RIGHT OPEN BOX OPERATOR
    {0x2ACF, 0x2AD0}, //CLOSED SUBSET
    {0x2AD0, 0x2ACF}, //CLOSED SUPERSET
    {0x2AD1, 0x2AD2}, //CLOSED SUBSET OR EQUAL TO
    {0x2AD2, 0x2AD1}, //CLOSED SUPERSET OR EQUAL TO
    {0x2AD3, 0x2AD4}, //SUBSET ABOVE SUPERSET
    {0x2AD4, 0x2AD3}, //SUPERSET ABOVE SUBSET
    {0x2AD5, 0x2AD6}, //SUBSET ABOVE SUBSET
    {0x2AD6, 0x2AD5}, //SUPERSET ABOVE SUPERSET
    {0x2ADE, 0x22A6}, //SHORT LEFT TACK
    {0x2AE3, 0x22A9}, //DOUBLE VERTICAL BAR LEFT TURNSTILE
    {0x2AE4, 0x22A8}, //VERTICAL BAR DOUBLE LEFT TURNSTILE
    {0x2AE5, 0x22AB}, //DOUBLE VERTICAL BAR DOUBLE LEFT TURNSTILE
    {0x2AEC, 0x2AED}, //DOUBLE STROKE NOT SIGN
    {0x2AED, 0x2AEC}, //REVERSED DOUBLE STROKE NOT SIGN
    {0x2AF7, 0x2AF8}, //TRIPLE NESTED LESS-THAN
    {0x2AF8, 0x2AF7}, //TRIPLE NESTED GREATER-THAN
    {0x2AF9, 0x2AFA}, //DOUBLE-LINE SLANTED LESS-THAN OR EQUAL TO
    {0x2AFA, 0x2AF9}, //DOUBLE-LINE SLANTED GREATER-THAN OR EQUAL TO
    {0x2E02, 0x2E03}, //LEFT SUBSTITUTION BRACKET
    {0x2E03, 0x2E02}, //RIGHT SUBSTITUTION BRACKET
    {0x2E04, 0x2E05}, //LEFT DOTTED SUBSTITUTION BRACKET
    {0x2E05, 0x2E04}, //RIGHT DOTTED SUBSTITUTION BRACKET
    {0x2E09, 0x2E0A}, //LEFT TRANSPOSITION BRACKET
    {0x2E0A, 0x2E09}, //RIGHT TRANSPOSITION BRACKET
    {0x2E0C, 0x2E0D}, //LEFT RAISED OMISSION BRACKET
    {0x2E0D, 0x2E0C}, //RIGHT RAISED OMISSION BRACKET
    {0x2E1C, 0x2E1D}, //LEFT LOW PARAPHRASE BRACKET
    {0x2E1D, 0x2E1C}, //RIGHT LOW PARAPHRASE BRACKET
    {0x2E20, 0x2E21}, //LEFT VERTICAL BAR WITH QUILL
    {0x2E21, 0x2E20}, //RIGHT VERTICAL BAR WITH QUILL
    {0x2E22, 0x2E23}, //TOP LEFT HALF BRACKET
    {0x2E23, 0x2E22}, //TOP RIGHT HALF BRACKET
    {0x2E24, 0x2E25}, //BOTTOM LEFT HALF BRACKET
    {0x2E25, 0x2E24}, //BOTTOM RIGHT HALF BRACKET
    {0x2E26, 0x2E27}, //LEFT SIDEWAYS U BRACKET
    {0x2E27, 0x2E26}, //RIGHT SIDEWAYS U BRACKET
    {0x2E28, 0x2E29}, //LEFT DOUBLE PARENTHESIS
    {0x2E29, 0x2E28}, //RIGHT DOUBLE PARENTHESIS
    {0x3008, 0x3009}, //LEFT ANGLE BRACKET
    {0x3009, 0x3008}, //RIGHT ANGLE BRACKET
    {0x300A, 0x300B}, //LEFT DOUBLE ANGLE BRACKET
    {0x300B, 0x300A}, //RIGHT DOUBLE ANGLE BRACKET
    {0x300C, 0x300D}, //[BEST FIT] LEFT CORNER BRACKET
    {0x300D, 0x300C}, //[BEST FIT] RIGHT CORNER BRACKET
    {0x300E, 0x300F}, //[BEST FIT] LEFT WHITE CORNER BRACKET
    {0x300F, 0x300E}, //[BEST FIT] RIGHT WHITE CORNER BRACKET
    {0x3010, 0x3011}, //LEFT BLACK LENTICULAR BRACKET
    {0x3011, 0x3010}, //RIGHT BLACK LENTICULAR BRACKET
    {0x3014, 0x3015}, //LEFT TORTOISE SHELL BRACKET
    {0x3015, 0x3014}, //RIGHT TORTOISE SHELL BRACKET
    {0x3016, 0x3017}, //LEFT WHITE LENTICULAR BRACKET
    {0x3017, 0x3016}, //RIGHT WHITE LENTICULAR BRACKET
    {0x3018, 0x3019}, //LEFT WHITE TORTOISE SHELL BRACKET
    {0x3019, 0x3018}, //RIGHT WHITE TORTOISE SHELL BRACKET
    {0x301A, 0x301B}, //LEFT WHITE SQUARE BRACKET
    {0x301B, 0x301A}, //RIGHT WHITE SQUARE BRACKET
    {0xFE59, 0xFE5A}, //SMALL LEFT PARENTHESIS
    {0xFE5A, 0xFE59}, //SMALL RIGHT PARENTHESIS
    {0xFE5B, 0xFE5C}, //SMALL LEFT CURLY BRACKET
    {0xFE5C, 0xFE5B}, //SMALL RIGHT CURLY BRACKET
    {0xFE5D, 0xFE5E}, //SMALL LEFT TORTOISE SHELL BRACKET
    {0xFE5E, 0xFE5D}, //SMALL RIGHT TORTOISE SHELL BRACKET
    {0xFE64, 0xFE65}, //SMALL LESS-THAN SIGN
    {0xFE65, 0xFE64}, //SMALL GREATER-THAN SIGN
    {0xFF08, 0xFF09}, //FULLWIDTH LEFT PARENTHESIS
    {0xFF09, 0xFF08}, //FULLWIDTH RIGHT PARENTHESIS
    {0xFF1C, 0xFF1E}, //FULLWIDTH LESS-THAN SIGN
    {0xFF1E, 0xFF1C}, //FULLWIDTH GREATER-THAN SIGN
    {0xFF3B, 0xFF3D}, //FULLWIDTH LEFT SQUARE BRACKET
    {0xFF3D, 0xFF3B}, //FULLWIDTH RIGHT SQUARE BRACKET
    {0xFF5B, 0xFF5D}, //FULLWIDTH LEFT CURLY BRACKET
    {0xFF5D, 0xFF5B}, //FULLWIDTH RIGHT CURLY BRACKET
    {0xFF5F, 0xFF60}, //FULLWIDTH LEFT WHITE PARENTHESIS
    {0xFF60, 0xFF5F}, //FULLWIDTH RIGHT WHITE PARENTHESIS
    {0xFF62, 0xFF63}, //[BEST FIT] HALFWIDTH LEFT CORNER BRACKET
    {0xFF63, 0xFF62}  //[BEST FIT] HALFWIDTH RIGHT CORNER BRACKET
};

#define BID_MIRROR_TABLE_SIZE (sizeof(_g_nMirrors)/sizeof(_g_nMirrors[0]))

BOOLEAN msAPI_MLE_TEXTUTIL_BidiIsParagraphChar( MLE_WChar nChar )
{
    BOOLEAN bReturn = FALSE;

    if ( _msAPI_MLE_BidiGetCharType(nChar, FALSE) == BIDI_B )
    {
        bReturn = TRUE;
    }

    return bReturn;
}

BOOLEAN msAPI_MLE_TEXTUTIL_BidiIsRTLChar( MLE_WChar nChar )
{
    Bidi_CharType_e eCharType = BIDI_ON;

    eCharType = _msAPI_MLE_BidiGetCharType(nChar, FALSE);
    if ( eCharType == BIDI_R || eCharType == BIDI_AN || eCharType == BIDI_AL )
    {
        return TRUE;
    }

    return FALSE;
}
#endif //__BIDI_TEXT__
U32 msAPI_MLE_TEXTUTIL_BidiGetParagraphLength( const MLE_WChar *pString, U32 nStrLen )
{
    U32 i = 0;
    U32 nReturnValue = 0;

    if ( pString == NULL || nStrLen == 0 )
    {
        return 0;
    }

    nReturnValue = nStrLen;
    while ( i < nStrLen )
    {
#ifdef __BIDI_TEXT__
       if ( _msAPI_MLE_BidiGetCharType(pString[i], FALSE) == BIDI_B )
#else
       if (pString[i] == TEXT_LINE_FEED || pString[i] == TEXT_CARRIAGE_RETURN)
#endif //__BIDI_TEXT__
       {
           if ( i < (nStrLen - 1) && ((pString[i] == TEXT_CARRIAGE_RETURN && pString[i + 1] == TEXT_LINE_FEED)
                                      || (pString[i] == TEXT_LINE_FEED && pString[i + 1] == TEXT_CARRIAGE_RETURN)))
           {
               nReturnValue = i + 2;
           }
           else
           {
               nReturnValue = i + 1;
           }

           break;
       }
       i++;
    }

    return nReturnValue;
}

BOOLEAN msAPI_MLE_TEXTUTIL_BidiOrderParagraph( MLE_WChar *pString, U32 *pStrLen, BOOLEAN bDisplayRight2Left, U16 **ppu16SeqPos, U8 **pCharLevel )
{
    U32 nParagraphSize = 0;
    Bidi_LineTable_t *pLineTable = NULL;
#ifdef __BIDI_TEXT__
    U16 *pTempSeqPos = NULL;
    U32 nStartIndex = 0;
    U32 nStartOffset = 0;
#endif //__BIDI_TEXT__
    if ( pString == NULL || pStrLen == NULL || *pStrLen == 0 )
    {
        return FALSE;
    }
#ifdef __BIDI_TEXT__
    if ( ppu16SeqPos )
    {
        pTempSeqPos = (U16 *)MALLOC( sizeof(U16) * (*pStrLen) );
        *ppu16SeqPos = pTempSeqPos;

        //init logical string position
        _msAPI_MLE_BidiInitLogicalPos( pTempSeqPos, *pStrLen );
    }
#endif //__BIDI_TEXT__
    *pStrLen = _msAPI_MLE_BidiResolveParagraph( pString, *pStrLen, 0 ); // get string length
    if ( nParagraphSize > 1 )
    {
        // init the line table if it is exist and is not user defined.
        // create line table if it is not exist.
        pLineTable = _msAPI_MLE_BidiTableAlloc(10);
        _msAPI_MLE_BidiTableDefaultMeasureLines( &pLineTable, pString, *pStrLen, bDisplayRight2Left );

#ifdef __BIDI_TEXT__
        _msAPI_MLE_BidiOrderString( pString,
                          pTempSeqPos,
                          0,
                          *pStrLen,
                          bDisplayRight2Left,
                          pLineTable,
                          &nStartIndex,
                          &nStartOffset,
                          pCharLevel );
#endif //__BIDI_TEXT__

        _msAPI_MLE_BidiTableFree( pLineTable );
    }

    return TRUE;
}

void* msAPI_MLE_TEXTUTIL_BidiCreateHandler( void )
{
    Bidi_Handler_t *pTempHandler = NULL;

    pTempHandler = MALLOC(sizeof(Bidi_Handler_t));
    if ( pTempHandler )
    {
        pTempHandler->pLineTable = NULL;
        pTempHandler->pOrderStr = NULL;
        pTempHandler->nStrLen = 0;
        pTempHandler->pLogicalPosInLine = NULL;
        pTempHandler->pCharLevel = NULL;
        pTempHandler->bUserTable = FALSE;
    }
    return (void *)pTempHandler;
}

void msAPI_MLE_TEXTUTIL_BidiFreeHandler( void *pHandler )
{
    Bidi_Handler_t *pThis = (Bidi_Handler_t *)pHandler;

    if ( pThis == NULL )
    {
        return;
    }

    FREEIF ( pThis->pOrderStr );
    FREEIF ( pThis->pLogicalPosInLine );
    FREEIF ( pThis->pCharLevel );

    _msAPI_MLE_BidiTableFree(pThis->pLineTable);
    FREE(pThis);
}

#ifdef __BIDI_TEXT__
BOOLEAN msAPI_MLE_TEXTUTIL_BidiOrderText( void *pHandler, const MLE_WChar *pString, U32 nStrLen, BOOLEAN bDisplayRight2Left )
{
    Bidi_Handler_t *pThis = (Bidi_Handler_t *)pHandler;
    U32 nParagraphSize = 0;
    U32 nStrOffset = 0;
    U32 nStartIndex = 0;
    U32 nStartOffset = 0;

    if ( pString == NULL || pHandler == NULL || nStrLen == 0 )
    {
        return FALSE;
    }

    FREEIF ( pThis->pOrderStr );
    FREEIF ( pThis->pLogicalPosInLine );
    FREEIF ( pThis->pCharLevel );

    pThis->nStrLen = nStrLen;
    pThis->pOrderStr = (U16 *)MALLOC(sizeof(U16) * nStrLen);
    if(pThis->pOrderStr == NULL)
    {
        return FALSE;
    }
    MEMCPY( (void *)pThis->pOrderStr, (void *)pString, sizeof(U16) * nStrLen );
    
    pThis->pLogicalPosInLine = (U16 *)MALLOC( sizeof(U16) * nStrLen );
    if(pThis->pLogicalPosInLine == NULL)
    {
        FREEIF(pThis->pOrderStr);
        return FALSE;
    }
    
    pThis->pCharLevel = (U8 *)MALLOC( sizeof(U8) * nStrLen );
    if(pThis->pCharLevel == NULL)
    {
        FREEIF(pThis->pOrderStr);
        FREEIF(pThis->pLogicalPosInLine);
        return FALSE;
    }
    MEMSET( (void *)pThis->pCharLevel, 0, sizeof(U8) * nStrLen );

    // init the line table if it is exist and is not user defined.
    // create line table if it is not exist.
    if ( pThis->pLineTable == NULL )
    {
        pThis->pLineTable = _msAPI_MLE_BidiTableAlloc(10);
        if(pThis->pLineTable == NULL)
        {
            FREEIF(pThis->pOrderStr);
            FREEIF(pThis->pLogicalPosInLine);
            FREEIF(pThis->pCharLevel);
            return FALSE;
        }
    }

    pThis->bIsDisplayRTL = bDisplayRight2Left;

    //get each paragraph and order it
    while ( nStrOffset < nStrLen )
    {
        nParagraphSize = _msAPI_MLE_BidiResolveParagraph( pThis->pOrderStr, nStrLen, nStrOffset );
        if ( nParagraphSize > 0 )
        {
            // only one change line character in paragraph
            if ( nParagraphSize == 1 && (_msAPI_MLE_BidiGetCharType(pThis->pOrderStr[nStrOffset], FALSE) == BIDI_B) )
            {
                // add a change line to line table if the table is not user defined.
                // continue next paragraph.
                pThis->pLogicalPosInLine[nStrOffset] = 0;
                pThis->pCharLevel[nStrOffset] = bDisplayRight2Left;
                if ( !pThis->bUserTable )
                {
                    TTF_TRACE(printf("%d %s\n", __LINE__, __FUNCTION__));
                    if ( _msAPI_MLE_BidiTableAddLine( &(pThis->pLineTable), nStrOffset, nParagraphSize, bDisplayRight2Left) == NULL )
                    {
                        FREEIF(pThis->pOrderStr);
                        FREEIF(pThis->pLogicalPosInLine);
                        FREEIF(pThis->pCharLevel);
                        //FREEIF(pThis->pLineTable);  //FIX ME, in this project, I think we should free this memory block here
                        return FALSE;
                    }
                }
                nStartIndex = nStartIndex + 1;
                nStartOffset = 0;
            }
            else
            {
                U8 *pTempCharLevel = NULL;

                if ( !pThis->bUserTable )
                {
                    TTF_TRACE(printf("%d %s\n", __LINE__, __FUNCTION__));
                    if ( _msAPI_MLE_BidiTableDefaultMeasureLines( &(pThis->pLineTable), (pThis->pOrderStr + nStrOffset), nStrLen, bDisplayRight2Left ) == FALSE )
                    {
                        FREEIF(pThis->pOrderStr);
                        FREEIF(pThis->pLogicalPosInLine);
                        FREEIF(pThis->pCharLevel);
                        //FREEIF(pThis->pLineTable);  //FIX ME, in this project, I think we should free this memory block here
                        return FALSE;
                    }
                }
                if ( _msAPI_MLE_BidiOrderString( pThis->pOrderStr, pThis->pLogicalPosInLine, nStrOffset, nParagraphSize, bDisplayRight2Left, pThis->pLineTable, &nStartIndex, &nStartOffset, &pTempCharLevel ) == FALSE )
                {
                    FREEIF(pThis->pOrderStr);
                    FREEIF(pThis->pLogicalPosInLine);
                    FREEIF(pThis->pCharLevel);
                    //FREEIF(pThis->pLineTable);  //FIX ME, in this project, I think we should free this memory block here
                    return FALSE;
                }

                if ( pTempCharLevel )
                {
                    MEMCPY( (void *)(pThis->pCharLevel + nStrOffset), (void *)pTempCharLevel, sizeof(U8) * nParagraphSize );
                }
                FREEIF ( pTempCharLevel );
            }
            nStrOffset = nStrOffset + nParagraphSize;
        }
        else
        {
            break;
        }
    }
    return TRUE;
}
#endif //__BIDI_TEXT__

BOOLEAN msAPI_MLE_TEXTUTIL_BidiInsertText( void *pHandler, const MLE_WChar *pString, U32 nStrLen, BOOLEAN bDisplayRight2Left )
{
    Bidi_Handler_t *pThis = (Bidi_Handler_t *)pHandler;
    U32 nParagraphSize = 0;
    U32 nStrOffset = 0;

    if ( pString == NULL || pHandler == NULL || nStrLen == 0 )
    {
        return FALSE;
    }

    FREEIF ( pThis->pOrderStr );
    FREEIF ( pThis->pLogicalPosInLine );
    FREEIF ( pThis->pCharLevel );

    pThis->nStrLen = nStrLen;
    pThis->pOrderStr = (U16 *)MALLOC(sizeof(U16) * nStrLen);
    MEMCPY( (void *)pThis->pOrderStr, (void *)pString, sizeof(U16) * nStrLen );
    pThis->pLogicalPosInLine = (U16 *)MALLOC( sizeof(U16) * nStrLen );
    pThis->pCharLevel = (U8 *)MALLOC( sizeof(U8) * nStrLen );
    MEMSET( (void *)pThis->pCharLevel, 0, sizeof(U8) * nStrLen );

    // init the line table if it is exist and is not user defined.
    // create line table if it is not exist.
    if ( pThis->pLineTable == NULL )
    {
        pThis->pLineTable = _msAPI_MLE_BidiTableAlloc(10);
    }

    pThis->bIsDisplayRTL = bDisplayRight2Left;

    //get each paragraph and order it
    if ( pThis->bUserTable )
    {
        Bidi_LineData_t *pLine = NULL;
        U32 i = 0;

        for ( i = 0; i < pThis->pLineTable->tTableInf.nLines; i++ )
        {
            pLine = (Bidi_LineData_t *)BIDI_GET_LINE( pThis->pLineTable, i );
            if ( pLine )
            {
                _msAPI_MLE_BidiInitLogicalPos( pThis->pLogicalPosInLine + pLine->nOffset, pLine->nLength );
            }
        }
    }
    else
    {
        while ( nStrOffset < nStrLen )
        {
            nParagraphSize = _msAPI_MLE_BidiResolveParagraph( pThis->pOrderStr, nStrLen, nStrOffset );
            if ( nParagraphSize > 0 )
            {
                //init logical string position
                _msAPI_MLE_BidiInitLogicalPos( pThis->pLogicalPosInLine + nStrOffset, nParagraphSize );
                _msAPI_MLE_BidiTableAddLine( &(pThis->pLineTable), nStrOffset, nParagraphSize, bDisplayRight2Left );
                nStrOffset = nStrOffset + nParagraphSize;
            }
            else
            {
                break;
            }
        }
    }
    return TRUE;
}

BOOLEAN msAPI_MLE_TEXTUTIL_BidiReorderText( void *pHandler, U32 nOffset, const MLE_WChar *pString, U32 nStrLen )
{
    Bidi_Handler_t *pThis = (Bidi_Handler_t *)pHandler;
    Bidi_LineData_t *pLine = NULL;
    U32 nParagraphSize = 0;
    U32 nStrOffset = 0;
    U32 nStartOffset = 0;
    U16 *pTempStr = NULL;
    U32 nParagraphStartLine = 0;
    BOOLEAN bDisplayRight2Left = FALSE;
    U32 i = 0;
    U8 *pTempCharLevel = NULL;

    if ( pString == NULL || pHandler == NULL || nStrLen == 0
         || pThis->pLineTable == NULL || pThis->pLineTable->tTableInf.nLines == 0 )
    {
        return FALSE;
    }

    if ( nOffset >= pThis->nStrLen  )
    {
        nOffset = pThis->nStrLen - 1;
    }

    bDisplayRight2Left = pThis->bIsDisplayRTL;

    //find the first match paragraph and reset bidi data
    while ( nStrOffset < nStrLen )
    {
        nParagraphSize = _msAPI_MLE_BidiResolveParagraph(pString, nStrLen, nStrOffset );

        // check the paragraph is include the update line
        if ( nStrOffset <= nOffset && (nStrOffset + nParagraphSize) > nOffset )
        {
            if ( nParagraphSize > 0 )
            {
                // copy SPRINTF order string and input string
                pTempStr = (U16 *)MALLOC(sizeof(U16) * nStrLen);
                _RET_IF_NULL(pTempStr);
                MEMCPY( (void *)pTempStr, (void *)pThis->pOrderStr, sizeof(U16) * nStrOffset );
                MEMCPY( (void *)(pTempStr + nStrOffset), (void *)(pString + nStrOffset), sizeof(U16) * (nStrLen - nStrOffset) );
                FREEIF( pThis->pOrderStr );
                pThis->pOrderStr = pTempStr;

                pTempStr = (U16 *)MALLOC(sizeof(U16) * nStrLen);
                _RET_IF_NULL(pTempStr);
                MEMCPY( (void *)pTempStr, (void *)pThis->pLogicalPosInLine, sizeof(U16) * nStrOffset );
                FREEIF( pThis->pLogicalPosInLine );
                pThis->pLogicalPosInLine = pTempStr;
                pTempCharLevel = (U8 *)MALLOC(sizeof(U8) * nStrLen);
                _RET_IF_NULL(pTempCharLevel);
                MEMCPY( (void *)pTempCharLevel, (void *)pThis->pCharLevel, sizeof(U8) * nStrOffset );
                FREEIF( pThis->pCharLevel );
                pThis->pCharLevel = pTempCharLevel;
                pTempCharLevel = NULL;

                pThis->nStrLen = nStrLen;

                if ( !pThis->bUserTable )
                {
                    // reset line information after the paragraph line
                    MEMSET( (void *)BIDI_GET_LINE(pThis->pLineTable, nParagraphStartLine),
                            0,
                            sizeof(Bidi_LineData_t) * (pThis->pLineTable->tTableInf.nLines - nParagraphStartLine) );

                    pThis->pLineTable->tTableInf.nLines = nParagraphStartLine;
                }
            }
            else
            {
                return FALSE;
            }
            break;
        }
        else
        {
            nStrOffset = nStrOffset + nParagraphSize;

            // calculate the first line of next paragraph
            for ( i = nParagraphStartLine; i < pThis->pLineTable->tTableInf.nLines; i++ )
            {
                pLine = (Bidi_LineData_t *)BIDI_GET_LINE( pThis->pLineTable, i );

                if ( nStrOffset >= pLine->nOffset && nStrOffset < pLine->nOffset + pLine->nLength )
                {
                    nParagraphStartLine = i;
                    break;
                }
            }
        }
    }


    while ( nStrOffset < nStrLen )
    {
        nParagraphSize = _msAPI_MLE_BidiResolveParagraph(pString, nStrLen, nStrOffset );

        // only one change line character in paragraph
#ifdef __BIDI_TEXT__
        if ( nParagraphSize == 1 && (_msAPI_MLE_BidiGetCharType(pThis->pOrderStr[nStrOffset], FALSE) == BIDI_B) )
#else
        if ( nParagraphSize == 1 && (pThis->pOrderStr[nStrOffset]== TEXT_LINE_FEED || pThis->pOrderStr[nStrOffset]== TEXT_CARRIAGE_RETURN) )
#endif //__BIDI_TEXT__
        {
            // add a change line to line table if the table is not user defined.
            // continue next paragraph.
            pThis->pLogicalPosInLine[nStrOffset] = 0;
            pThis->pCharLevel[nStrOffset] = bDisplayRight2Left;
            if ( !pThis->bUserTable )
            {
                _msAPI_MLE_BidiTableAddLine( &(pThis->pLineTable), nStrOffset, nParagraphSize, bDisplayRight2Left);
            }
            nParagraphStartLine = nParagraphStartLine + 1;
            nStartOffset = 0;
        }
        else
        {
            if ( !pThis->bUserTable )
            {
                _msAPI_MLE_BidiTableDefaultMeasureLines( &(pThis->pLineTable), (pThis->pOrderStr + nStrOffset), nStrLen, bDisplayRight2Left );
            }

            _msAPI_MLE_BidiOrderString( pThis->pOrderStr, pThis->pLogicalPosInLine, nStrOffset, nParagraphSize, bDisplayRight2Left, pThis->pLineTable, &nParagraphStartLine, &nStartOffset, &pTempCharLevel );

            if ( pTempCharLevel )
            {
                MEMCPY( (void *)(pThis->pCharLevel + nStrOffset), (void *)pTempCharLevel, sizeof(U8) * nParagraphSize );
            }
            FREEIF ( pTempCharLevel );
        }

        nStrOffset = nStrOffset + nParagraphSize;
    }

    return TRUE;
}

void msAPI_MLE_TEXTUTIL_BidiInitTable( void *pHandler )
{
    Bidi_Handler_t *pThis = (Bidi_Handler_t *)pHandler;

    pThis->bUserTable = FALSE;

    _msAPI_MLE_BidiTableFree( pThis->pLineTable );
    pThis->pLineTable = _msAPI_MLE_BidiTableAlloc( 10 );
}

BOOLEAN msAPI_MLE_TEXTUTIL_BidiAddLine( void *pHandler, U32 nOffset, U32 nStrLen, BOOLEAN bRTL )
{
    Bidi_Handler_t *pThis = (Bidi_Handler_t *)pHandler;

    if ( pThis->pLineTable == NULL )
    {
        pThis->pLineTable = _msAPI_MLE_BidiTableAlloc(10);
    }

    pThis->bUserTable = TRUE;

    return _msAPI_MLE_BidiTableAddLine( &(pThis->pLineTable), nOffset, nStrLen, bRTL );
}

BOOLEAN msAPI_MLE_TEXTUTIL_BidiModifyLineInfo( void *pHandler, U32 u32Line, U32 nOffset, U32 nStrLen, BOOLEAN bRTL )
{
    Bidi_Handler_t *pThis = (Bidi_Handler_t *)pHandler;
    Bidi_LineData_t *pLine = NULL;

    if ( pThis->pLineTable == NULL || u32Line >= pThis->pLineTable->tTableInf.nLines )
    {
        return FALSE;
    }

    pThis->bUserTable = TRUE;

    pLine = (Bidi_LineData_t *)BIDI_GET_LINE( pThis->pLineTable, u32Line );
    pLine->bRight2Left = bRTL;
    pLine->nOffset = nOffset;
    pLine->nLength = nStrLen;

    return TRUE;
}

U32 msAPI_MLE_TEXTUTIL_BidiGetTableSize( void *pHandler )
{
    Bidi_Handler_t *pThis = (Bidi_Handler_t *)pHandler;

    if ( pHandler == NULL )
    {
        return 0;
    }

    return pThis->pLineTable->tTableInf.nLines;
}

BOOLEAN msAPI_MLE_TEXTUTIL_BidiSetTableSize( void *pHandler, U32 nSize )
{
    Bidi_Handler_t *pThis = (Bidi_Handler_t *)pHandler;

    if ( pThis == NULL || pThis->pLineTable->tTableInf.nMaxLines < nSize )
    {
        return FALSE;
    }

    pThis->pLineTable->tTableInf.nLines = nSize;

    return TRUE;
}

U16* msAPI_MLE_TEXTUTIL_BidiGetOrderStr( void *pHandler, U32 *pStrLen )
{
    Bidi_Handler_t *pThis = (Bidi_Handler_t *)pHandler;

    if ( pHandler == NULL )
    {
        return NULL;
    }

    if ( pStrLen )
    {
        *pStrLen = pThis->nStrLen;
    }

    return pThis->pOrderStr;
}

BOOLEAN msAPI_MLE_TEXTUTIL_BidiGetLineInf( void *pHandler, U32 nIndex, U32 *pOffset, U32 *pLineStrLen, BOOLEAN *pRTL, MLE_WChar **ppwLineString, U16 **ppSeqInLine, U8 **pCharLevel )
{
    Bidi_Handler_t *pThis = (Bidi_Handler_t *)pHandler;
    Bidi_LineData_t *pLine = NULL;

    if ( pHandler == NULL || nIndex >= pThis->pLineTable->tTableInf.nLines )
    {
        return FALSE;
    }

    pLine = (Bidi_LineData_t *)BIDI_GET_LINE(pThis->pLineTable,nIndex);

    if ( pOffset )
    {
        *pOffset = pLine->nOffset;
    }

    if ( pLineStrLen )
    {
        *pLineStrLen = pLine->nLength;
    }

    if ( pRTL )
    {
        *pRTL = pLine->bRight2Left;
    }

    if ( ppwLineString )
    {
        if ( pThis->pOrderStr )
        {
            *ppwLineString = (U16 *)MALLOC(sizeof(U16) * pLine->nLength);
            MEMCPY( (void *)(*ppwLineString), (void *)(pThis->pOrderStr + pLine->nOffset), sizeof(U16) * pLine->nLength );
        }
        else
        {
            *ppwLineString = NULL;
        }
    }

    if ( ppSeqInLine )
    {
        if ( pThis->pLogicalPosInLine )
        {
            *ppSeqInLine = (U16 *)MALLOC(sizeof(U16) * pLine->nLength);
            MEMCPY( (void *)(*ppSeqInLine), (void *)(pThis->pLogicalPosInLine + pLine->nOffset), sizeof(U16) * pLine->nLength );
        }
        else
        {
            *ppSeqInLine = NULL;
        }
    }

    if ( pCharLevel )
    {
        if ( pThis->pCharLevel )
        {
            *pCharLevel = (U8 *)MALLOC(sizeof(U16) * pLine->nLength);
            MEMCPY( (void *)(*pCharLevel), (void *)(pThis->pCharLevel + pLine->nOffset), sizeof(U8) * pLine->nLength );
        }
        else
        {
            *pCharLevel = NULL;
        }
    }
    return TRUE;
}

static void _msAPI_MLE_BidiInitLogicalPos( U16 *pStrPos, U32 nStrLen )
{
    U32 i;

    if ( pStrPos == NULL )
    {
        return;
    }

    for ( i = 0; i < nStrLen; i++ )
    {
        pStrPos[i] = i;
    }
}

#ifdef __BIDI_TEXT__
static Bidi_CharType_e _msAPI_MLE_BidiGetCharType( MLE_WChar nChar, BOOLEAN bReportWsType )
{
    Bidi_CharType_e eResult;

    if ( ((nChar >= 0x0600) && (nChar <= 0x06EF))
         || ((nChar >= 0x06FA) && (nChar <= 0x07BF))
         || ((nChar >= 0xFB50) && (nChar <= 0xFDFF))
         || ((nChar >= 0xFE70) && (nChar <= 0xFEFF)) )
    {
        if ( (nChar >= 0x0660) && (nChar <= 0x066D) )
        {
            eResult = BIDI_AN;
        }
        else
        {
            eResult = BIDI_AL;
        }
    }
    else if ( ((nChar >= 0x0590) && (nChar <= 0x05FF))
              || ((nChar >= 0xFB1D) && (nChar <= 0xFB4F)) )
    {
        eResult = BIDI_R;
    }
    else if ( ((nChar >= 0x0030) && (nChar <= 0x0039))
              || ((nChar >= 0x06F0) && (nChar <= 0x06F9)) )
    {
        eResult = BIDI_EN;
    }
    else if ( (nChar & 0xFF00) == 0x0000 )
    {
        U8 nColChar = (U8)(nChar & 0x00FF);
        if ( bReportWsType )
        {
            eResult = (Bidi_CharType_e)_g_nBidiTypesFromChar[nColChar];
        }
        else
        {
            eResult = (Bidi_CharType_e)_g_nBidiNTypes[_g_nBidiTypesFromChar[nColChar]];
        }
    }
    else
    {
        eResult = BIDI_L;
    }

    return eResult;
}
#endif //__BIDI_TEXT__

//[in] nOffset: the start offset of input string
//[in] u16StrLen: the input string length
//[out]: the paragraph length
static U32 _msAPI_MLE_BidiResolveParagraph( const MLE_WChar *pString, U32 nStrLen, U32 nOffset )
{
    U32 nReturnValue = 0;

    if ( pString == NULL || nOffset >= nStrLen )
    {
        return 0;
    }

    nReturnValue = msAPI_MLE_TEXTUTIL_BidiGetParagraphLength( pString + nOffset,  nStrLen - nOffset );

    return nReturnValue;
}

static BOOLEAN _msAPI_MLE_BidiOrderString( MLE_WChar *pString, U16 *pPosInLine, U32 nOffset, U32 nSubStrLen, BOOLEAN bRight2Left, Bidi_LineTable_t *pTable, U32 *pStartIndex, U32 *pStartOffset, U8 **ppnCharLevel )
{
    Bidi_LineData_t *pLine = NULL;
    U16 *pCharTypes;
    U8 *pCharLevels;
#ifdef __BIDI_TEXT__
    U8 nBaseLevel = 0;
#endif //__BIDI_TEXT__
    U32 nLineLen = 0;
    U32 nLineOffset = 0;
    U32 nCurrentLine = 0;
    U32 nOrderOffset = 0;
    U32 nOrderRemainLen = 0;
    U32 i, j;

    if ( pTable == NULL || pString == NULL || nSubStrLen == 0
         || pStartIndex == NULL || pStartOffset == NULL
         || *pStartIndex >= pTable->tTableInf.nLines
         || pPosInLine == NULL )
    {
        return FALSE;
    }

    pCharTypes = (U16 *)MALLOC( nSubStrLen * 2 );
    if (NULL == pCharTypes)
    {
        return FALSE;
    }   
    pCharLevels = (U8 *)MALLOC( nSubStrLen );
    if (NULL == pCharLevels)
    {
        FREEIF(pCharTypes);
        return FALSE;
    }
    //if (NULL == pCharTypes || NULL == pCharLevels)
    //{
        //return FALSE;
    //}

#ifdef __BIDI_TEXT__
    // convert to directional types
    // u16StrLen maybe change because match the paragraph control character
    _msAPI_MLE_BidiConvertCharType( (pString + nOffset), pCharTypes, &nSubStrLen, FALSE );

    // set paragraph level(base level) and compute character types
    if ( bRight2Left )
    {
        nBaseLevel = 1;
    }

    // resolve explicit
    _msAPI_MLE_BidiResolveExplicit( nBaseLevel, pCharTypes, pCharLevels, nSubStrLen );

    // resolve weak
    _msAPI_MLE_BidiResolveWeak( nBaseLevel, pCharTypes, pCharLevels, nSubStrLen );

    // resolve neutrals
    _msAPI_MLE_BidiResolveNeutrals( nBaseLevel, pCharTypes, pCharLevels, nSubStrLen );

    // resolveImplicit
    _msAPI_MLE_BidiResolveImplicit( pCharTypes, pCharLevels, nSubStrLen );

    // convert to directional types
    _msAPI_MLE_BidiConvertCharType( (pString + nOffset), pCharTypes, &nSubStrLen, TRUE );
#endif //__BIDI_TEXT__
    nOrderRemainLen = nSubStrLen;

    for ( i = *pStartIndex; i < pTable->tTableInf.nLines; i++ )
    {
        pLine = (Bidi_LineData_t *)BIDI_GET_LINE(pTable, i);

        if ( pLine->nOffset >= (nOffset + nSubStrLen) )
        {
            break;
        }

        nCurrentLine = i;

        if ( pLine->nLength > *pStartOffset )
        {
            nLineLen = MIN(pLine->nLength - (*pStartOffset), nOrderRemainLen);
        }
        else
        {
            *pStartOffset = 0;
            continue;
        }
        nLineOffset = pLine->nOffset + (*pStartOffset);

        //init logical string position
        _msAPI_MLE_BidiInitLogicalPos( pPosInLine + nLineOffset, nLineLen );
#ifdef __BIDI_TEXT__
        _msAPI_MLE_BidiOrderLine( pString + nLineOffset,
                        pCharTypes + nOrderOffset,
                        pCharLevels + nOrderOffset,
                        pPosInLine + nLineOffset,
                        nLineLen,
                        nBaseLevel );
#endif //__BIDI_TEXT__
        if ( *pStartOffset > 0 )
        {
            for ( j = 0; j < nLineLen; j++ )
            {
                pPosInLine[nLineOffset + j] = pPosInLine[nLineOffset + j] + (*pStartOffset);
            }

            //next line is begin from 0
            *pStartOffset = 0;
        }
        else
        {
            // set the line direction
            pLine->bRight2Left = bRight2Left;
        }
#ifdef __BIDI_TEXT__
        _msAPI_MLE_BidiOrderCharLevel( (pPosInLine + nLineOffset), nLineLen, pCharLevels + nOrderOffset );
#endif //__BIDI_TEXT__
        nOrderOffset = nOrderOffset + nLineLen;
        nOrderRemainLen = nOrderRemainLen - nLineLen;
    }

    pLine = (Bidi_LineData_t *)BIDI_GET_LINE(pTable, nCurrentLine);

    // paragraph length smaller than current line
    if ( (pLine->nOffset + pLine->nLength) > (nOffset + nSubStrLen) )
    {
        // set paragraph index and offset
        *pStartIndex = nCurrentLine;
        *pStartOffset = nOffset + nSubStrLen - pLine->nOffset;
    }
    else
    {
        *pStartIndex = nCurrentLine + 1;
        *pStartOffset = 0;
    }

    FREEIF( pCharTypes );

    if ( ppnCharLevel )
    {
        *ppnCharLevel = pCharLevels;
    }
    else
    {
        FREEIF( pCharLevels );
    }

    return TRUE;
} /* end of kid_OrderArabicString */

 #ifdef __BIDI_TEXT__
static void _msAPI_MLE_BidiConvertCharType( MLE_WChar *pString, U16 *pCharTypes, U32 *pStrLen, BOOLEAN bReportWsType )
{
    U16 nUcs2Char;
    U16 nPreCharType = BIDI_ON;
    U16 nNextCharType = BIDI_ON;
    U32 i;

    for ( i = 0; i < *pStrLen; i++ )
    {
        nUcs2Char = pString[i];
        pCharTypes[i] = (U16)_msAPI_MLE_BidiGetCharType( nUcs2Char, bReportWsType );

        // limit text to first block
        if ( pCharTypes[i] == BIDI_B )
        {
            if ( i < (*pStrLen - 1) && pString[i] == 0x000D && pString[i + 1] == 0x000A )
            {
                pCharTypes[i] = BIDI_BN;
                pCharTypes[i + 1] = BIDI_BN;
                *pStrLen = i + 2;
            }
            else
            {
                pCharTypes[i] = BIDI_BN;
                *pStrLen = i + 1;
            }
            break;
        }
        else
        {
            // for special case
            switch ( pString[i] )
            {
                // replace "+" and "-" to EN type if following a EN type, but not followed a EN type
                // if following a EN type and followed a EN type, replace by ON
                case 0x002B:
                case 0x002D:
                    if ( (i + 1) < *pStrLen )
                    {
                        nNextCharType = (U16)_msAPI_MLE_BidiGetCharType( pString[i+1], bReportWsType );
                        if ( nNextCharType == BIDI_EN )
                        {
                            if ( nPreCharType == BIDI_EN )
                            {
                                pCharTypes[i] = BIDI_ON;
                            }
                            else
                            {
                                pCharTypes[i] = BIDI_EN;
                            }
                        }
                    }
                    break;

                // replace "/" to maths symbol type if following a EN type, and followed a EN type
                case 0x002F:
                    if ( (i + 1) < *pStrLen )
                    {
                        nNextCharType = (U16)_msAPI_MLE_BidiGetCharType( pString[i+1], bReportWsType );
                        if ( nNextCharType == BIDI_EN && nPreCharType == BIDI_EN )
                        {
                            pCharTypes[i] = BIDI_ON;
                        }
                    }
                    break;
            }
        }
        nPreCharType = pCharTypes[i];
    }
}

static void _msAPI_MLE_BidiResolveExplicit( U8 nBaseLevel, U16 *pCharTypes, U8 *pCharLevels, U32 nStrLen )
{
    U8 nStackIndex = 0;
    U8 nLevelStack[BIDI_LEVEL_MAX_SIZE] = {0};
    U16 nOverrideStatus[BIDI_LEVEL_MAX_SIZE] = {0};
    Bidi_CharType_e eCurrentCharType = BIDI_N;
    U32 i;

    for ( i = 0; i < nStrLen; i++ )
    {
        switch ( pCharTypes[i] )
        {
            case BIDI_LRO:
            case BIDI_LRE:
                if ( nStackIndex < BIDI_LEVEL_MAX_SIZE )
                {
                    nLevelStack[nStackIndex] = nBaseLevel;
                    nBaseLevel = ((nBaseLevel & 1) ? (nBaseLevel + 1) : (nBaseLevel + 2));
                    nOverrideStatus[nStackIndex] = (U16)eCurrentCharType;
                    nStackIndex ++;

                    if ( pCharTypes[i] == BIDI_LRO )
                    {
                        //BID_LRO: reset the override status to left-to-right
                        eCurrentCharType = BIDI_L;
                    }
                    else
                    {
                        //BID_LRE: reset the override status to neutral
                        eCurrentCharType = BIDI_N;
                    }
                }
                pCharTypes[i] = BIDI_BN;
                break;

            case BIDI_RLO:
            case BIDI_RLE:
                if ( nStackIndex < BIDI_LEVEL_MAX_SIZE )
                {
                    nLevelStack[nStackIndex] = nBaseLevel;
                    nBaseLevel = ((nBaseLevel & 1) ? (nBaseLevel + 2) : (nBaseLevel + 1));
                    nOverrideStatus[nStackIndex] = (U16)eCurrentCharType;
                    nStackIndex ++;

                    if ( pCharTypes[i] == BIDI_RLO )
                    {
                        //BID_LRO: reset the override status to right-to-left
                        eCurrentCharType = BIDI_R;
                    }
                    else
                    {
                        //BID_RLE: reset the override status to neutral
                        eCurrentCharType = BIDI_N;
                    }
                }
                pCharTypes[i] = BIDI_BN;
                break;

            case BIDI_PDF:
                if ( nStackIndex > 0 )
                {
                    nStackIndex --;
                    nBaseLevel = nLevelStack[nStackIndex];
                    eCurrentCharType = (Bidi_CharType_e)nOverrideStatus[nStackIndex];
                }
                pCharTypes[i] = BIDI_BN;
                break;

            default:
                // Apply the embedding level
                pCharLevels[i] = nBaseLevel;

                if ( pCharTypes[i] != BIDI_BN )
                {
                    //Apply to the current override status
                    if ( (eCurrentCharType == BIDI_R) || (eCurrentCharType == BIDI_L) )
                    {
                        pCharTypes[i] = (U16)eCurrentCharType;
                    }
                }
                break;
        }
    }
}


static void _msAPI_MLE_BidiResolveWeak( U8 pBaselevel, U16 *pCharTypes, U8 *pCharLevels, U32 nStrLen )
{
    Bidi_WeakState_e eState = ((pBaselevel & 1) ? BIDI_WEAK_XR : BIDI_WEAK_XL);
    U32 i;
    U8 nLevel = pBaselevel;
    U32 nDeferredCount = 0;
    Bidi_CharType_e eCurrentCharType;
    U16 nAction;

    for ( i = 0; i < nStrLen; i++ )
    {
        // ignore boundary neutrals
        if ( pCharTypes[i] == BIDI_BN )
        {
            // must flatten levels unless at a level change;
            pCharLevels[i] = nLevel;

            // lookahead for level changes
            if ( (i + 1 == nStrLen) && (nLevel != pBaselevel) )
            {
                // have to fixup last BN before end of the loop, since
                // its fix-upped value will be needed below the assert
                pCharTypes[i] = ((pBaselevel & 1) ? BIDI_R : BIDI_L);
            }
            else if ( (i + 1 < nStrLen) && (nLevel != pCharLevels[i + 1])
                      && (pCharTypes[i + 1] != BIDI_BN) )
            {
                // fixup LAST BN in front / after a level run to make
                // it act like the SOR/EOR in rule X10
                U8 u8Newlevel = pCharLevels[i + 1];

                if ( nLevel > u8Newlevel )
                {
                    u8Newlevel = nLevel;
                }
                pCharLevels[i] = u8Newlevel;

                // must match assigned level
                // level change ==> end of this level run
                pCharTypes[i] = ((u8Newlevel & 1) ? BIDI_R : BIDI_L);
                nLevel = pCharLevels[i+1];
            }
            else
            {
                // don't interrupt runs
                if ( nDeferredCount )
                {
                    nDeferredCount ++;
                }
                continue;
           }
       }

       ASSERT( pCharTypes[i] <= BIDI_BN );
       eCurrentCharType = (Bidi_CharType_e)pCharTypes[i];

       nAction = _g_nBidiActionWeak[eState][eCurrentCharType];

       // resolve the directionality for deferred runs
       if ( ((nAction >> 4) & 0xF) != BIDI_WEAK_ACT_XX )
       {
           U32 j;
           for ( j = i; j > (i - nDeferredCount); j-- )
           {
               pCharTypes[j - 1] = ((nAction >> 4) & 0xF);
           }
           nDeferredCount = 0;
       }

       // resolve the directionality class at the current location
       if ( (nAction & 0xF) != BIDI_WEAK_ACT_XX )
       {
           pCharTypes[i] = (nAction & 0xF);
       }

       // increment a deferred run
       if ( BIDI_WEAK_ACT_IX & nAction )
       {
           nDeferredCount ++;
       }
       eState = (Bidi_WeakState_e)_g_nBidiStateWeak[eState][eCurrentCharType];
    }

    // resolve any deferred runs
    // use the direction of the current level to emulate PDF
    eCurrentCharType = ((nLevel & 1) ? BIDI_R : BIDI_L);

    // resolve the directionality for deferred runs
    if ( ((_g_nBidiActionWeak[eState][eCurrentCharType] >> 4) & 0xF) != BIDI_WEAK_ACT_XX )
    {
        U32 j;
        for ( j = i; j > (i - nDeferredCount); j-- )
        {
            pCharTypes[j - 1] = ((_g_nBidiActionWeak[eState][eCurrentCharType] >> 4) & 0xF);
        }
    }
}

static void _msAPI_MLE_BidiResolveNeutrals( U8 pBaselevel, U16 *pCharTypes, U8 *pCharLevels, U32 nStrLen )
{
    Bidi_NeutralState_e eState = ((pBaselevel & 1) ? BIDI_NEUTRAL_R : BIDI_NEUTRAL_L);
    U32 i;
    U32 nDeferredCount = 0;
    U8 nLevel = pBaselevel;
    U16 nAction;
    U16 nActionRun;
    U16 nNewActionRun;
    Bidi_CharType_e eCurrentCharType;

    for ( i = 0; i < nStrLen; i++ )
    {
        // ignore boundary neutrals
        if ( pCharTypes[i] == BIDI_BN )
        {
            // include in the count for a deferred run
            if (nDeferredCount)
            {
                nDeferredCount++;
            }
            // skip any further processing
            continue;
        }

        ASSERT(pCharTypes[i] < 5); // "Only N, L, R,  AN, EN are allowed"
        eCurrentCharType = (Bidi_CharType_e)pCharTypes[i];

        nAction = _g_nBidiActionNeutrals[eState][eCurrentCharType];

        // resolve the directionality for deferred runs
        if ( ((nAction >> 4) & 0xF) == (BIDI_NEUTRAL_ACT_EN >> 4) )
        {
            nActionRun = ((nLevel & 1) ? BIDI_R : BIDI_L);
        }
        else
        {
            nActionRun = (nAction >> 4) & 0xF;
        }

        if ( nActionRun != BIDI_N )
        {
            U32 j;

            for ( j = i; j > (i - nDeferredCount); j-- )
            {
                pCharTypes[j - 1] = nActionRun;
            }
            nDeferredCount = 0;
        }

        // resolve the directionality class at the current location
        if ( (nAction & 0xF) == (U8)BIDI_NEUTRAL_ACT_IN )
        {
            nNewActionRun = BIDI_N;
        }
        else
        {
            nNewActionRun = nAction & 0xF;
        }
        if (nNewActionRun != BIDI_N)
            pCharTypes[i] = nNewActionRun;

        if ( BIDI_NEUTRAL_ACT_IN & nAction )
            nDeferredCount++;

        eState = (Bidi_NeutralState_e)_g_nBidiStateNeutrals[eState][eCurrentCharType];
        nLevel = pCharLevels[i];
    }

    // resolve any deferred runs
    eCurrentCharType = ((nLevel & 1) ? BIDI_R : BIDI_L);    // eor has type of current level

    // resolve the directionality for deferred runs
    if ( ((_g_nBidiActionNeutrals[eState][eCurrentCharType] >> 4) & 0xF) == (BIDI_NEUTRAL_ACT_EN >> 4) )
    {
        nActionRun = ((nLevel & 1) ? BIDI_R : BIDI_L);
    }
    else
    {
        nActionRun = ((_g_nBidiActionNeutrals[eState][eCurrentCharType] >> 4) & 0xF);
    }

    if ( nActionRun != BIDI_N )
    {
        U32 j;

        for ( j = i; j > (i - nDeferredCount); j-- )
        {
            pCharTypes[j - 1] = nActionRun;
        }
    }
}

static void _msAPI_MLE_BidiResolveImplicit( U16 *pCharTypes, U8 *pCharLevels, U32 nStrLen )
{
    U32 i;

    for ( i = 0; i < nStrLen; i++ )
    {
        // cannot resolve bn here, since some bn were resolved to strong
        // types in resolveWeak. To remove these we need the original
        // types, which are available again in resolveWhiteSpace
        if ( pCharTypes[i] == BIDI_BN )
        {
            continue;
        }
        ASSERT( pCharTypes[i] > 0 ); // "No Neutrals allowed to survive here."
        ASSERT( pCharTypes[i] < 5 ); // "Out of range."

        pCharLevels[i] += _g_nBidiAddLevel[((pCharLevels[i]) & 1)][pCharTypes[i] - 1];
    }
}

static void _msAPI_MLE_BidiOrderLine( MLE_WChar *pString, U16 *pCharTypes, U8 *pCharLevels, U16 *pu16LogicPos, U32 nStrLen, U8 nBaseLevel )
{
    U32 u32OrderLength = 0;

    if ( pString == NULL || pCharTypes == NULL || pCharLevels == NULL )
    {
        return;
    }

    _msAPI_MLE_BidiResolveWhitespace( nBaseLevel, pCharTypes, pCharLevels, nStrLen );

    _msAPI_MLE_BidiMirrorStr( pString, pCharLevels, nStrLen );

    // reorder each line in place
    u32OrderLength = 0;
    while ( u32OrderLength < nStrLen )
    {
        u32OrderLength += _msAPI_MLE_BidiReorderLevel( nBaseLevel,
                                             pString,
                                             pCharLevels,
                                             nStrLen,
                                             u32OrderLength,
                                             nStrLen - u32OrderLength,
                                             FALSE,
                                             pu16LogicPos );
    }
    u32OrderLength = 0;
}

static void _msAPI_MLE_BidiResolveWhitespace( U8 nBaseLevel, U16 *pCharTypes, U8 *pCharLevels, U32 nStrLen )
{
    U32 i, j;
    U8 u8CharLevel = 0;
    U8 u8Oldlevel = nBaseLevel;

    if ( pCharTypes == NULL || pCharLevels == NULL )
    {
        return;
    }

    for ( i = 0; i < nStrLen; i++ )
    {
        switch( pCharTypes[i] )
        {
            case BIDI_WS:
                u8CharLevel++;
                break;

            case BIDI_RLE:
            case BIDI_LRE:
            case BIDI_LRO:
            case BIDI_RLO:
            case BIDI_PDF:
            case BIDI_BN:
               pCharLevels[i] = u8Oldlevel;
               u8CharLevel++;
               break;

            case BIDI_S:
            case BIDI_B:
                // reset levels for WS before eot
                for ( j = i; j > i - u8CharLevel; j-- )
                {
                    pCharLevels[j - 1] = nBaseLevel;
                }
                u8CharLevel = 0;
                pCharLevels[i] = nBaseLevel;
                break;

            default:
                u8CharLevel = 0; // any other character breaks the run
                break;
        }
        u8Oldlevel = pCharLevels[i];
    }

    // reset level before eot
    for ( j = i; j > i - u8CharLevel; j-- )
    {
        pCharLevels[j - 1] = nBaseLevel;
    }
}


static void _msAPI_MLE_BidiMirrorStr( MLE_WChar *pString, U8 *pCharLevels, U32 nStrLen )
{
    U32 i;

    for ( i = 0; i < nStrLen; i ++ )
    {
        if ( !((pCharLevels[i]) & 1) )
            continue;

        _msAPI_MLE_BidiDoMirror( &(pString[i]), (S32)0, (S32)(BID_MIRROR_TABLE_SIZE - 1) );
    }
}

static BOOLEAN _msAPI_MLE_BidiDoMirror( MLE_WChar *pChar, S32 nStartIndex, S32 nEndIndex )
{
    S32 s32MidIndex;

    if ( nStartIndex < 0 || nEndIndex < 0 || nEndIndex < nStartIndex || pChar == NULL )
    {
        return FALSE;
    }

    s32MidIndex = nStartIndex + (nEndIndex - nStartIndex)/2;

    if ( *pChar == _g_nMirrors[s32MidIndex][0] )
    {
        *pChar = _g_nMirrors[s32MidIndex][1];
        return TRUE;
    }
    else
    {
        if ( *pChar > _g_nMirrors[s32MidIndex][0] )
        {
            return _msAPI_MLE_BidiDoMirror( pChar, (s32MidIndex + 1), nEndIndex );
        }
        else if ( *pChar < _g_nMirrors[s32MidIndex][0] )
        {
            return _msAPI_MLE_BidiDoMirror( pChar, nStartIndex, (s32MidIndex - 1) );
        }
    }
    return FALSE;
}

static U32 _msAPI_MLE_BidiReorderLevel( U8 nLevel, MLE_WChar *pText, U8 *pCharlevels, U32 nStrLen, U32 nOffset, U32 nSubLen, BOOLEAN bReverse, U16 *pRealPos )
{
    U32 i;

    if ( nSubLen == 0 )
    {
        return 0;
    }

    // TRUE as soon as first odd level encountered
    bReverse = (bReverse || (nLevel & 1));

    for ( i = nOffset; i < nOffset + nSubLen; i++ )
    {
        if ( pCharlevels[i] < nLevel )
        {
            break;
        }
        else if ( pCharlevels[i] > nLevel )
        {
            i += _msAPI_MLE_BidiReorderLevel( nLevel + 1,
                                    pText,
                                    pCharlevels,
                                    nStrLen,
                                    i,
                                    (nOffset + nSubLen) - i,
                                    bReverse,
                                    pRealPos ) - 1;
        }
    }
    if ( bReverse )
    {
        msAPI_MLE_TEXTUTIL_UCS2Invert( pText, nStrLen, nOffset, (i - nOffset), pRealPos );
    }
    return (i - nOffset);
}
#endif //__BIDI_TEXT__

static Bidi_LineTable_t* _msAPI_MLE_BidiTableAlloc( U32 nLineSize )
{
    Bidi_LineTable_t *pTempTable;
    pTempTable = (Bidi_LineTable_t *)MALLOC((sizeof(Bidi_LineData_t) * nLineSize) + sizeof(Bidi_LineTable_t));
    if ( pTempTable != NULL )
    {
        pTempTable->tTableInf.nMaxLines = nLineSize;
        pTempTable->tTableInf.nLines = 0;
    }

    return pTempTable;
}

static void _msAPI_MLE_BidiTableFree( Bidi_LineTable_t *pLineTable )
{
    if ( pLineTable == NULL )
    {
        return;
    }
    FREEIF( pLineTable );
}

static BOOLEAN _msAPI_MLE_BidiTableAddLine( Bidi_LineTable_t **ppLineTable, U32 nOffset, U32 nSubLen, BOOLEAN bRight2Left )
{
    Bidi_LineData_t *pTempLineInf = NULL;

    if ( ppLineTable == NULL )
    {
        return FALSE;
    }

    if ( (*ppLineTable)->tTableInf.nLines >= (*ppLineTable)->tTableInf.nMaxLines )
    {
        //Extension table size
        (*ppLineTable) = (Bidi_LineTable_t *)REALLOC( (void *)(*ppLineTable), (sizeof(Bidi_LineData_t) * ((*ppLineTable)->tTableInf.nMaxLines + 10)) + sizeof(Bidi_TableData_t) );
        if ( (*ppLineTable) == NULL )
        {
            return FALSE;
        }
        MEMSET( (void *)BIDI_GET_LINE((*ppLineTable),(*ppLineTable)->tTableInf.nMaxLines), 0, sizeof(Bidi_LineData_t) * 10 );
        (*ppLineTable)->tTableInf.nMaxLines = (*ppLineTable)->tTableInf.nMaxLines + 10;
    }

    pTempLineInf = (Bidi_LineData_t *)BIDI_GET_LINE((*ppLineTable),(*ppLineTable)->tTableInf.nLines);
    pTempLineInf->bRight2Left = bRight2Left;
    pTempLineInf->nOffset = nOffset;
    pTempLineInf->nLength = nSubLen;
    (*ppLineTable)->tTableInf.nLines = (*ppLineTable)->tTableInf.nLines + 1;

    return TRUE;
}

static BOOLEAN _msAPI_MLE_BidiTableDefaultMeasureLines( Bidi_LineTable_t **ppTable, MLE_WChar *pString, U32 nStrLen, BOOLEAN bRight2Left )
{
    U16 u32SubOffset = 0;
    U16 u16ParagraphLen = 0;

    if ( ppTable == NULL || pString == NULL )
    {
        return FALSE;
    }

    // break lines at change line character
    while ( u32SubOffset < nStrLen )
    {
        u16ParagraphLen = msAPI_MLE_TEXTUTIL_BidiGetParagraphLength( pString + u32SubOffset,  nStrLen - u32SubOffset );
        if ( _msAPI_MLE_BidiTableAddLine( ppTable, u32SubOffset, u16ParagraphLen, bRight2Left ) == FALSE )
            return FALSE;
        u32SubOffset = u32SubOffset + u16ParagraphLen;
    }

    if ( u32SubOffset < nStrLen )
    {
        if ( _msAPI_MLE_BidiTableAddLine( ppTable, u32SubOffset, nStrLen - u32SubOffset, bRight2Left ) == FALSE )
            return FALSE;
    }
    
    return TRUE;
}

#ifdef __BIDI_TEXT__
static void _msAPI_MLE_BidiOrderCharLevel( U16 *pPosInLine, U32 nLen, U8 *pCharLevels )
{
    U8 *pu8TempCharLevels = NULL;
    U32 i = 0;

    if ( pPosInLine == NULL || pCharLevels == NULL )
    {
        return;
    }

    pu8TempCharLevels = (U8 *)MALLOC( sizeof(U8) * nLen );
    if(NULL == pu8TempCharLevels) return;
    MEMCPY( (void *)pu8TempCharLevels, (void *)pCharLevels, sizeof(U8) * nLen );

    for ( i = 0; i < nLen; i++ )
    {
        pCharLevels[i] = pu8TempCharLevels[pPosInLine[i]];
    }

    FREEIF( pu8TempCharLevels );
}
#endif //__BIDI_TEXT__
